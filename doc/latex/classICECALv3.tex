\hypertarget{classICECALv3}{
\section{ICECALv3 Class Reference}
\label{classICECALv3}\index{ICECALv3@{ICECALv3}}
}


{\ttfamily \#include $<$ICECALv3.h$>$}Inheritance diagram for ICECALv3::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classICECALv3}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235}{Attribut} \{ \par
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a3a8da2ab97dda18aebab196fe4100531}{UNDEFINED}, 
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a2bfb2af57b87031d190a05fe25dd92ed}{PASSIVE}, 
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a3b1fec929c0370d1436f2f06e298fb0d}{ACTIVE}, 
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235aa27c16b480a369ea4d18b07b2516bbc7}{INTERFACE}, 
\par
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a1420a5b8c0540b2af210b6975eded7f9}{IO}, 
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a0af3b0d0ac323c1704e6c69cf90add28}{IODATA}, 
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a7788bc5dd333fd8ce18562b269c9dab1}{ELEMENT}, 
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a61ceb22149f365f1780d18f9d1459423}{HARDWARE}, 
\par
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a75250e29692496e73effca2c0330977f}{PROCESSUS}, 
\hyperlink{classAttrib_a69e171d7cc6417835a5a306d3c764235a103a67cd0b8f07ef478fa45d4356e27b}{SOFTWARE}
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classICECALv3_a0a8b12d2b6bafca9cd820301fc93dff8}{ICECALv3} ()
\item 
void \hyperlink{classICECALv3_aaf38119f47401a85022ae1b0d05675bd}{setAddress} (\hyperlink{LSDelayChipV1_8h_a3cb25ca6f51f003950f9625ff05536fc}{U8} address)
\item 
void \hyperlink{classICECALv3_aae0b7539c0bba5311aab99e000d1be6d}{setNRetries} (int nRet)
\item 
void \hyperlink{classICECALv3_a1b9ca0e09d45634a70da6f19a7257314}{resetPumps} ()
\item 
void \hyperlink{classICECALv3_a5ce36881aa89fedf7c37e03620acca6e}{bypassMisoMosi} (\hyperlink{LSDelayChipV1_8h_adf928e51a60dba0df29d615401cc55a8}{U16} writeData)
\item 
PyObject $\ast$ \hyperlink{classICECALv3_a7a1c1706a455903f42bb9a5257d94a78}{getDelayLineCh} (int ch)
\item 
\hyperlink{classStatusCode}{StatusCode} \hyperlink{classICECALv3_a14a7a29c9a3412c062f053cc616b860a}{setDelayLineCh} (int ch, PyObject $\ast$)
\item 
PyObject $\ast$ \hyperlink{classICECALv3_a5f1414e6049a82eafdd505a88d7d0c91}{getAnalogCh} (int ch)
\item 
\hyperlink{classStatusCode}{StatusCode} \hyperlink{classICECALv3_a9578e4d13c250d8bc417f68c79d6a21d}{setAnalogCh} (int ch, PyObject $\ast$)
\item 
PyObject $\ast$ \hyperlink{classICECALv3_a4a414d23c1e199b446dc876161338148}{getMainReg} ()
\item 
\hyperlink{classStatusCode}{StatusCode} \hyperlink{classICECALv3_a479f7e17669da4b785af840049d39cb4}{setMainReg} (PyObject $\ast$)
\item 
PyObject $\ast$ \hyperlink{classICECALv3_a8639cf6a44cba85b53128b5e1dc21e15}{spiFERTest} (long nTest)
\item 
\hyperlink{classStatusCode}{StatusCode} \hyperlink{classICECALv3_ac26be912fb72e615106fceb4626aa548}{dumpConfig} (string configFile, PyObject $\ast$chipId)
\item 
PyObject $\ast$ \hyperlink{classICECALv3_a514456dd303e897aa1b55dccf3fa66d0}{loadConfig} (string configFile)
\item 
double \hyperlink{classICECALv3_a7f3f8012d2e5c45f8e43819befa3f915}{version} ()
\item 
bool \hyperlink{classICECALv3_a545f51b915a6de5c5f450622d0651a85}{bxidResynchStatus} ()
\item 
void \hyperlink{classICECALv3_acbf1a7a8510d7e02280bacc58badf4f4}{spiAddressScan} ()
\item 
\hyperlink{classICECALv3_acdadf9483fc38a615192de41548024a1}{$\sim$ICECALv3} ()
\item 
void \hyperlink{classICECALv3_a00e572849b4952e7cf04a39f992df037}{help} ()
\item 
\hyperlink{classStatusCode}{StatusCode} \hyperlink{classICECALv3_abf7281fad80b80b70c5b13ce66ba3451}{init} ()
\item 
void \hyperlink{classICECALv3_a33afc7c8e0f399336152abd03cbe8d1b}{reset} ()
\item 
void \hyperlink{classICECALv3_ab2a00809e9a4f2ab83ef041a886ca637}{update} ()
\item 
void \hyperlink{classElement_a3c0abcb36f8906688bb7e32608df7086}{recursiveInitElement} ()
\item 
void \hyperlink{classElement_a82119ed37dff76508a2746a853ec35ba}{recursiveInitCommunications} ()
\item 
\hyperlink{classStatusCode}{StatusCode} \hyperlink{classElement_ab476b4b1df5954141ceb14f072433b89}{setConnection} (\hyperlink{classHierarchy}{Hierarchy} $\ast$)
\item 
\hyperlink{classHierarchy}{Hierarchy} $\ast$ \hyperlink{classElement_af57444353c1ddf9fa0109801e97debf7}{connection} ()
\item 
void \hyperlink{classHierarchy_af4d43b0765b402670eed2d62c73405af}{clear} ()
\item 
void \hyperlink{classHierarchy_a585ad1aeec16077a0e532ab8b4fc557b}{setParent} (\hyperlink{classHierarchy}{Hierarchy} $\ast$parent)
\item 
\hyperlink{classHierarchy}{Hierarchy} $\ast$ \hyperlink{classHierarchy_a1c7bec8257e717f9c1465e06ebf845fc}{parent} ()
\item 
\hyperlink{classHierarchy}{Hierarchy} $\ast$ \hyperlink{classHierarchy_ad550588733bf75ac5c0fcfd7c8fd11a6}{parent} (std::string)
\item 
\hyperlink{classHierarchy}{Hierarchy} $\ast$ \hyperlink{classHierarchy_aee461dc930ce3871636ff87f075b1b83}{origin} ()
\item 
virtual void \hyperlink{classHierarchy_ad677774ff38fcb257c04a3a10d471fac}{addChild} (\hyperlink{classHierarchy}{Hierarchy} $\ast$element)
\item 
std::vector$<$ \hyperlink{classHierarchy}{Hierarchy} $\ast$ $>$ \hyperlink{classHierarchy_aa9a76f69e98e052ee1a6e32cea006288}{children} ()
\item 
\hyperlink{classHierarchy}{Hierarchy} $\ast$ \hyperlink{classHierarchy_a1e207f973c694b538bf90107b4868817}{child} (std::string)
\item 
\hyperlink{classHierarchy}{Hierarchy} $\ast$ \hyperlink{classHierarchy_a0c15a5276a3b80b4354d6bd8a01e0708}{childTyped} (std::string)
\item 
unsigned long \hyperlink{classHierarchy_ab16e84de65fd84e14001a6cf941c8be4}{numberOfChildren} ()
\item 
bool \hyperlink{classHierarchy_a255174fe4d316d2a3f430dcb9dab29f1}{hasChildren} ()
\item 
void \hyperlink{classHierarchy_a2b2b359fac003233f65786a616766bde}{delChild} (\hyperlink{classHierarchy}{Hierarchy} $\ast$)
\item 
void \hyperlink{classHierarchy_a1928ac7615fe0b5e55cd707f70dc6781}{delChild} (std::string)
\item 
std::string \hyperlink{classHierarchy_aa7990fa7caf132d83e361ce033c6c65a}{path} (std::string=std::string(\char`\"{}\char`\"{}))
\item 
std::string \hyperlink{classHierarchy_a1efd56cd164d328d2002e53a10a19b8c}{pathTyped} (std::string=std::string(\char`\"{}\char`\"{}))
\item 
void \hyperlink{classHierarchy_a76e914b9a677a22a82deb74d892bf261}{tree} (std::string indent=std::string(\char`\"{}\char`\"{}))
\item 
void \hyperlink{classHierarchy_a594c294c5f60c230e106d522ed008212}{tree} ()
\item 
std::string \hyperlink{classObject_a975e888d50bfcbffda2c86368332a5cd}{name} () const 
\item 
std::string \hyperlink{classObject_a84f99f70f144a83e1582d1d0f84e4e62}{type} ()
\item 
unsigned char \hyperlink{classObject_af99145335cc61ff6e2798ea17db009d2}{id} ()
\item 
std::string \hyperlink{classObject_a73a0f1a41828fdd8303dd662446fb6c3}{title} ()
\item 
void \hyperlink{classObject_a3f9d5537ebce0c0f2bf6ae4d92426f3c}{msgSvc} (int level, std::string msg, std::string name)
\item 
void \hyperlink{classObject_a58b2d0618c2d08cf2383012611528d97}{msg} (std::string mymsg)
\item 
void \hyperlink{classObject_ac5d59299273cee27aacf7de00d2e7034}{msg} (std::string mymsg, std::string name)
\item 
void \hyperlink{classObject_a83d2db2df682907ea1115ad721c1c4a1}{verbose} (std::string mymsg)
\item 
void \hyperlink{classObject_a2d4120195317e2a3c6532e8bb9f3da68}{verbose} (std::string mymsg, std::string name)
\item 
void \hyperlink{classObject_aac010553f022165573714b7014a15f0d}{debug} (std::string mymsg)
\item 
void \hyperlink{classObject_a6c9a0397ca804e04d675ed05683f5420}{debug} (std::string mymsg, std::string name)
\item 
void \hyperlink{classObject_a644fd329ea4cb85f54fa6846484b84a8}{info} (std::string mymsg)
\item 
void \hyperlink{classObject_a1ca123253dfd30fc28b156f521dcbdae}{info} (std::string mymsg, std::string name)
\item 
void \hyperlink{classObject_a65cd4fda577711660821fd2cd5a3b4c9}{warning} (std::string mymsg)
\item 
void \hyperlink{classObject_a11f101db4dd73d9391b0231818881d86}{warning} (std::string mymsg, std::string name)
\item 
void \hyperlink{classObject_a204a95f57818c0f811933917a30eff45}{error} (std::string mymsg)
\item 
void \hyperlink{classObject_ad7f6c457733082efa2f9ff5f5c8e119a}{error} (std::string mymsg, std::string name)
\item 
void \hyperlink{classObject_aad5a16aac7516ce65bd5ec02ab07fc80}{fatal} (std::string mymsg)
\item 
void \hyperlink{classObject_ae62acd3d09f716220f75f252dc38bc9a}{fatal} (std::string mymsg, std::string name)
\item 
void \hyperlink{classObject_ae30fea75683c2d149b6b6d17c09ecd0c}{setName} (std::string name)
\item 
void \hyperlink{classObject_aae534cc9d982bcb9b99fd505f2e103a5}{setType} (std::string type)
\item 
void \hyperlink{classObject_a398fe08cba594a0ce6891d59fe4f159f}{setId} (unsigned char id)
\item 
void \hyperlink{classObject_a89557dbbad5bcaa02652f5d7fa35d20f}{setTitle} (std::string title)
\item 
void \hyperlink{classObject_a870c5af919958c2136623b2d7816d123}{setDllName} (std::string dllName)
\item 
std::string \hyperlink{classObject_a2e3947f2870094c332d7454117f3ec63}{dllName} ()
\item 
bool \hyperlink{classAttrib_a704f26af560909ad22065083bb7d4c34}{is} (int attribut)
\item 
void \hyperlink{classAttrib_a235f773af19c900264a190b00a3b4ad7}{add} (int attribut)
\item 
void \hyperlink{classAttrib_a7d4ef7e32d93cb287792b87b857e79f3}{remove} (int attribut)
\item 
std::string \hyperlink{classAttrib_aee7bbf16b144887f196e1341b24f8a26}{attributs} ()
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classHierarchy}{Hierarchy} $\ast$ \hyperlink{classElement_abe3de7a5dbbc9a6dd2d7e012e5fdb266}{m\_\-connection}
\item 
std::string \hyperlink{classAttrib_a3414521d7a82476e874b25a5407b5e63}{m\_\-attribString} \mbox{[}10\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{LSDelayChipV1_8h_adf928e51a60dba0df29d615401cc55a8}{U16} \hyperlink{classICECALv3_aced41ce20a0853d6248b8df88412e57a}{spiRead} (\hyperlink{LSDelayChipV1_8h_a3cb25ca6f51f003950f9625ff05536fc}{U8} confRegAddr, \hyperlink{LSDelayChipV1_8h_a3cb25ca6f51f003950f9625ff05536fc}{U8} offsetAddr=128)
\item 
void \hyperlink{classICECALv3_aef00f02801dea4bda2093c930501dcdd}{spiWrite} (\hyperlink{LSDelayChipV1_8h_a3cb25ca6f51f003950f9625ff05536fc}{U8} confRegAddr, \hyperlink{LSDelayChipV1_8h_adf928e51a60dba0df29d615401cc55a8}{U16} \hyperlink{structconfRegData}{confRegData})
\item 
bool \hyperlink{classICECALv3_aa0b8358ea0be8e47a8aded5e1551787f}{spiWriteSafe} (\hyperlink{LSDelayChipV1_8h_a3cb25ca6f51f003950f9625ff05536fc}{U8} confRegAddr, \hyperlink{LSDelayChipV1_8h_adf928e51a60dba0df29d615401cc55a8}{U16} \hyperlink{structconfRegData}{confRegData})
\item 
bool \hyperlink{classICECALv3_a9d7c33e6d113e7f721dc848d28ab44d8}{writeAsicParams} (string fileName, PyObject $\ast$params)
\item 
int \hyperlink{classICECALv3_a313e8166af1ce26b4026f883ad900fb9}{parseParameterList} (string configFile, string paramName\mbox{[}64\mbox{]}, int paramValue\mbox{[}64\mbox{]})
\item 
PyObject $\ast$ \hyperlink{classICECALv3_ac006abc42a048308427f6801d783a407}{fillParams} (string paramListRet\mbox{[}$\,$\mbox{]}, int paramListLen, string paramName\mbox{[}64\mbox{]}, int paramValue\mbox{[}64\mbox{]}, int fileParamLen)
\item 
bool \hyperlink{classICECALv3_a8753a74558f988b346a3fe350c5bbad4}{checkChNumber} (int ch)
\item 
std::string \hyperlink{classICECALv3_a04b02e583f191bfce34d05132cd23834}{itohs} (int value)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRegister}{Register} $\ast$ \hyperlink{classICECALv3_a6e8b6c03f5b0f1d8281bf8a0fa46064f}{confReg}
\item 
int \hyperlink{classICECALv3_ae877ce34b3a4d6c368cc6409ac9614fa}{nRetries}
\item 
bool \hyperlink{classICECALv3_ad8989925ee5b3ff322d863ce6aaff0bd}{err}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 58 of file ICECALv3.h.

\subsection{Member Enumeration Documentation}
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235}{
\index{ICECALv3@{ICECALv3}!Attribut@{Attribut}}
\index{Attribut@{Attribut}!ICECALv3@{ICECALv3}}
\subsubsection[{Attribut}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Attrib::Attribut}\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235}
\begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{UNDEFINED@{UNDEFINED}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!UNDEFINED@{UNDEFINED}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a3a8da2ab97dda18aebab196fe4100531}{
UNDEFINED}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a3a8da2ab97dda18aebab196fe4100531}
}]\index{PASSIVE@{PASSIVE}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!PASSIVE@{PASSIVE}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a2bfb2af57b87031d190a05fe25dd92ed}{
PASSIVE}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a2bfb2af57b87031d190a05fe25dd92ed}
}]\index{ACTIVE@{ACTIVE}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!ACTIVE@{ACTIVE}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a3b1fec929c0370d1436f2f06e298fb0d}{
ACTIVE}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a3b1fec929c0370d1436f2f06e298fb0d}
}]\index{INTERFACE@{INTERFACE}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!INTERFACE@{INTERFACE}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235aa27c16b480a369ea4d18b07b2516bbc7}{
INTERFACE}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235aa27c16b480a369ea4d18b07b2516bbc7}
}]\index{IO@{IO}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!IO@{IO}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a1420a5b8c0540b2af210b6975eded7f9}{
IO}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a1420a5b8c0540b2af210b6975eded7f9}
}]\index{IODATA@{IODATA}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!IODATA@{IODATA}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a0af3b0d0ac323c1704e6c69cf90add28}{
IODATA}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a0af3b0d0ac323c1704e6c69cf90add28}
}]\index{ELEMENT@{ELEMENT}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!ELEMENT@{ELEMENT}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a7788bc5dd333fd8ce18562b269c9dab1}{
ELEMENT}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a7788bc5dd333fd8ce18562b269c9dab1}
}]\index{HARDWARE@{HARDWARE}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!HARDWARE@{HARDWARE}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a61ceb22149f365f1780d18f9d1459423}{
HARDWARE}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a61ceb22149f365f1780d18f9d1459423}
}]\index{PROCESSUS@{PROCESSUS}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!PROCESSUS@{PROCESSUS}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a75250e29692496e73effca2c0330977f}{
PROCESSUS}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a75250e29692496e73effca2c0330977f}
}]\index{SOFTWARE@{SOFTWARE}!ICECALv3@{ICECALv3}}\index{ICECALv3@{ICECALv3}!SOFTWARE@{SOFTWARE}}\item[{\em 
\hypertarget{classAttrib_a69e171d7cc6417835a5a306d3c764235a103a67cd0b8f07ef478fa45d4356e27b}{
SOFTWARE}
\label{classAttrib_a69e171d7cc6417835a5a306d3c764235a103a67cd0b8f07ef478fa45d4356e27b}
}]\end{description}
\end{Desc}



Definition at line 29 of file Attrib.h.


\begin{DoxyCode}
29                 {
30     UNDEFINED,
31     PASSIVE,
32     ACTIVE,
33     INTERFACE,
34     IO,
35     IODATA,
36     ELEMENT,
37     HARDWARE,
38     PROCESSUS,
39     SOFTWARE 
40   }; // array m_attribString must be changed into Attrib::Attrib if this enu is m
      odified. 
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classICECALv3_a0a8b12d2b6bafca9cd820301fc93dff8}{
\index{ICECALv3@{ICECALv3}!ICECALv3@{ICECALv3}}
\index{ICECALv3@{ICECALv3}!ICECALv3@{ICECALv3}}
\subsubsection[{ICECALv3}]{\setlength{\rightskip}{0pt plus 5cm}ICECALv3::ICECALv3 ()}}
\label{classICECALv3_a0a8b12d2b6bafca9cd820301fc93dff8}


Definition at line 16 of file ICECALv3.cpp.

References Attrib::add(), Hierarchy::addChild(), IOdata::Byte, confReg, Object::debug(), IOdata::defDataU8(), Attrib::ELEMENT, Attrib::HARDWARE, IOobject::io(), Object::setId(), Object::setName(), IOdata::setSubAddress(), Object::setType(), and IOdata::setWordSize().


\begin{DoxyCode}
16                   {
17     setType("ICECALv3");
18     setId(0);
19 
20     add(Attrib::ELEMENT); add (Attrib::HARDWARE);
21     debug("ICECALv3 built.","ICECALv3::ICECALv3");
22 
23     //Configuration register initilization:
24     //Sub-address = 9.
25     //#bytes = 3 (address + data<1> + data<0>).
26     confReg=new Register();
27     confReg->setName("ConfigRegister");
28     confReg->io()->setSubAddress(9);    
29     confReg->io()->defDataU8(3);    
30     confReg->io()->setWordSize(IOdata::Byte);
31 
32     addChild(confReg);  
33 }
\end{DoxyCode}
\hypertarget{classICECALv3_acdadf9483fc38a615192de41548024a1}{
\index{ICECALv3@{ICECALv3}!$\sim$ICECALv3@{$\sim$ICECALv3}}
\index{$\sim$ICECALv3@{$\sim$ICECALv3}!ICECALv3@{ICECALv3}}
\subsubsection[{$\sim$ICECALv3}]{\setlength{\rightskip}{0pt plus 5cm}ICECALv3::$\sim$ICECALv3 ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classICECALv3_acdadf9483fc38a615192de41548024a1}


Definition at line 98 of file ICECALv3.h.


\begin{DoxyCode}
98              {
99   }
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classAttrib_a235f773af19c900264a190b00a3b4ad7}{
\index{ICECALv3@{ICECALv3}!add@{add}}
\index{add@{add}!ICECALv3@{ICECALv3}}
\subsubsection[{add}]{\setlength{\rightskip}{0pt plus 5cm}void Attrib::add (int {\em attribut})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classAttrib_a235f773af19c900264a190b00a3b4ad7}
Add an attribut 

Definition at line 67 of file Attrib.h.

References Attrib::m\_\-attributs, and Attrib::UNDEFINED.

Referenced by A3PE::A3PE(), Attrib::Attrib(), SpecsMezzanine::cmdline(), Computer::Computer(), CU\_\-v1::CU\_\-v1(), export\_\-obj(), FEB\_\-v1::FEB\_\-v1(), FePGA::FePGA(), ICECALv3(), ICPhaser::ICPhaser(), Application::initialize(), Interface::Interface(), IOdata::IOdata(), IOobject::IOobject(), LSDelayChipV1::LSDelayChipV1(), MSOxxxx::MSOxxxx(), Phaser::Phaser(), Processus::Processus(), Proto40MHz\_\-v1::Proto40MHz\_\-v1(), Attrib::remove(), SeqPGA::SeqPGA(), SpecsMaster::SpecsMaster(), and SpecsSlave::SpecsSlave().


\begin{DoxyCode}
67                             {
68     if (attribut!=Attrib::UNDEFINED) remove(Attrib::UNDEFINED);
69     bool duplicate = false ;
70     std::vector<int>::const_iterator iter ;
71     for ( iter  = m_attributs.begin() ;
72           iter != m_attributs.end()   ;
73           ++iter ) {
74       if ( attribut == (*iter) ) {
75         duplicate = true ;
76       }
77     }
78     if (!duplicate) {
79       m_attributs.push_back( attribut );
80     }
81   }
\end{DoxyCode}
\hypertarget{classHierarchy_ad677774ff38fcb257c04a3a10d471fac}{
\index{ICECALv3@{ICECALv3}!addChild@{addChild}}
\index{addChild@{addChild}!ICECALv3@{ICECALv3}}
\subsubsection[{addChild}]{\setlength{\rightskip}{0pt plus 5cm}void Hierarchy::addChild ({\bf Hierarchy} $\ast$ {\em element})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, inherited\mbox{]}}}}
\label{classHierarchy_ad677774ff38fcb257c04a3a10d471fac}


Definition at line 83 of file Hierarchy.cpp.

References Object::debug(), Hierarchy::m\_\-children, Object::name(), and Hierarchy::setParent().

Referenced by A3PE::A3PE(), SpecsMezzanine::addBus(), SpecsSlave::addI2c(), Application::create(), CU\_\-v1::CU\_\-v1(), export\_\-obj(), FEB\_\-v1::FEB\_\-v1(), FePGA::FePGA(), ICECALv3(), ICPhaser::ICPhaser(), LSDelayChipV1::LSDelayChipV1(), FePGA::MakeRAM(), FePGA::MakeRegister(), Phaser::Phaser(), Proto40MHz\_\-v1::Proto40MHz\_\-v1(), SeqPGA::SeqPGA(), SpecsMezzanine::SpecsMezzanine(), UsbI2cBus::UsbI2cBus(), and UsbSpiBus::UsbSpiBus().


\begin{DoxyCode}
83                                           {
84   element->setParent(this);
85   m_children.push_back(element);
86   debug(element->name()+" added to the child tree.","Hierarchy::addChild");
87 }
\end{DoxyCode}
\hypertarget{classAttrib_aee7bbf16b144887f196e1341b24f8a26}{
\index{ICECALv3@{ICECALv3}!attributs@{attributs}}
\index{attributs@{attributs}!ICECALv3@{ICECALv3}}
\subsubsection[{attributs}]{\setlength{\rightskip}{0pt plus 5cm}std::string Attrib::attributs ()\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classAttrib_aee7bbf16b144887f196e1341b24f8a26}
Print the \hyperlink{classAttrib}{Attrib} of an \hyperlink{classObject}{Object} 

Definition at line 54 of file Attrib.cpp.

References images::index, Attrib::m\_\-attribString, and Attrib::m\_\-attributs.

Referenced by export\_\-obj().


\begin{DoxyCode}
54                             {
55   std::string output;
56   std::vector<int>::iterator iter ;
57   for ( unsigned int index = 0 ; index < m_attributs.size() ; ++index ) {
58     if ( m_attributs.size() - index > 1 ) {
59       output.append(m_attribString[m_attributs[index]]);
60       output.append(":");
61     }
62     else {
63       output.append(m_attribString[m_attributs[index]]);
64     }
65   }
66   return output;
67 }
\end{DoxyCode}
\hypertarget{classICECALv3_a545f51b915a6de5c5f450622d0651a85}{
\index{ICECALv3@{ICECALv3}!bxidResynchStatus@{bxidResynchStatus}}
\index{bxidResynchStatus@{bxidResynchStatus}!ICECALv3@{ICECALv3}}
\subsubsection[{bxidResynchStatus}]{\setlength{\rightskip}{0pt plus 5cm}bool ICECALv3::bxidResynchStatus ()}}
\label{classICECALv3_a545f51b915a6de5c5f450622d0651a85}


Definition at line 677 of file ICECALv3.cpp.

References BXID\_\-RESYNCH\_\-ADDR, Object::info(), itohs(), and spiRead().

Referenced by BOOST\_\-PYTHON\_\-MODULE().


\begin{DoxyCode}
678 {
679     U16 rxData;
680 
681     rxData = spiRead(BXID_RESYNCH_ADDR, 0x00 );
682 
683     info("RX = " + itohs(rxData),"");
684     return(rxData > 127);
685 
686 }
\end{DoxyCode}
\hypertarget{classICECALv3_a5ce36881aa89fedf7c37e03620acca6e}{
\index{ICECALv3@{ICECALv3}!bypassMisoMosi@{bypassMisoMosi}}
\index{bypassMisoMosi@{bypassMisoMosi}!ICECALv3@{ICECALv3}}
\subsubsection[{bypassMisoMosi}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::bypassMisoMosi ({\bf U16} {\em writeData})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classICECALv3_a5ce36881aa89fedf7c37e03620acca6e}


Definition at line 70 of file ICECALv3.h.

References SC\_\-MOSI\_\-MISO\_\-BYPASS, and spiWrite().


\begin{DoxyCode}
70 {       spiWrite(SC_MOSI_MISO_BYPASS,writeData);    };
\end{DoxyCode}
\hypertarget{classICECALv3_a8753a74558f988b346a3fe350c5bbad4}{
\index{ICECALv3@{ICECALv3}!checkChNumber@{checkChNumber}}
\index{checkChNumber@{checkChNumber}!ICECALv3@{ICECALv3}}
\subsubsection[{checkChNumber}]{\setlength{\rightskip}{0pt plus 5cm}bool ICECALv3::checkChNumber (int {\em ch})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classICECALv3_a8753a74558f988b346a3fe350c5bbad4}


Definition at line 155 of file ICECALv3.h.

References Object::error(), and itos().


\begin{DoxyCode}
156     {
157         if(ch < 0 || ch > 3) {
158             error(itos(ch)+" is not a valid ICECAL channel number. Valid numbers 
      [0-3].","ICECALv3::checkChNumber");
159             return false;
160         }
161         else return true;
162     }
\end{DoxyCode}
\hypertarget{classHierarchy_a1e207f973c694b538bf90107b4868817}{
\index{ICECALv3@{ICECALv3}!child@{child}}
\index{child@{child}!ICECALv3@{ICECALv3}}
\subsubsection[{child}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Hierarchy} $\ast$ Hierarchy::child (std::string {\em path})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_a1e207f973c694b538bf90107b4868817}


Definition at line 133 of file Hierarchy.cpp.

References Hierarchy::child(), Hierarchy::children(), Object::name(), Hierarchy::origin(), Hierarchy::parent(), and Object::warning().

Referenced by Application::cd(), Hierarchy::child(), and export\_\-obj().


\begin{DoxyCode}
133                                          {
134   std::string newpath = path;
135   std::string up("..");
136   std::string separator(1,'/');
137 
138   Hierarchy * newcurrent = 0;
139 
140   //  info("path="+path,"Hierarchy::child");
141 
142   if (path.compare("")==0 || path.compare("/")==0) {
143     //    debug("return origin","Hierarchy::child");
144     return origin();
145   }
146 
147   if (path.compare(name())==0){
148     //    debug("return itself","Hierarchy::child");
149     return this;
150   }
151 
152   if (path.compare("..")==0){
153     if (0!=this->parent()) return this->parent();
154     else return this;
155   }
156 
157   if (path.compare("../")==0){
158     if (0!=this->parent()) return this->parent();
159     else return this;
160   }
161 
162 
163   int npos=path.find(separator,0);
164 
165   //  info("find separator in "+itos(npos)+" of "+path,"Hierarchy::child");
166 
167   // remove last separator
168   if ( npos == (int)(path.size()-1) ) {
169     newpath = std::string(path,0,npos);
170     path = newpath;
171   }
172 
173   if (npos==0){
174     //    debug("Going back to origin and calling child","Hierarchy::child");
175     newpath=std::string(path,1,path.size()-1);
176     return origin()->child(newpath);
177   }
178   else{
179     if ( npos== (int)(std::string::npos) ){
180       //      debug("Getting chid "+path+" of "+this->name(),"Hierarchy::child");
      
181       std::vector <Hierarchy*> list = children();
182       std::vector<Hierarchy*>::iterator iter;
183       for (iter=list.begin();iter!=list.end();iter++){
184         if ((*iter)->name().compare(path)==0){
185           return *iter;
186         }
187       }
188       warning(this->name()+std::string(" has no child '")+path+"'","Hierarchy::ch
      ild");
189       return this;
190     }
191     else
192     {
193       int ipos=path.find(separator,0);
194       //      info("default behaviour "+path+" with separator in "+itos(ipos),"Hi
      erarchy::child");
195 
196       std::string newcurrentname=std::string(path,0,ipos);
197       newpath=std::string(path,ipos+1,path.size()-1);
198 
199       //      info("looking now for "+newpath+" from "+newcurrentname,"Hierarchy:
      :child");
200 
201       if (0==newcurrentname.compare(origin()->name())){
202         //        info("current is computer. Looking for children"+newcurrentname
      ,"Hierarchy::child");
203         return origin()->child(newpath);
204       }
205 
206       newcurrent = (Hierarchy*)0;
207 
208       std::vector <Hierarchy*> list = children();
209       std::vector<Hierarchy*>::iterator iter;
210       for (iter=list.begin();iter!=list.end();iter++){
211         if ((*iter)->name().compare(newcurrentname)==0){
212           newcurrent = (*iter);
213         }
214       }
215 
216 
217       if ((Hierarchy*)0==newcurrent){
218         if (newcurrentname.compare("..")==0 && 0!=parent()){
219           newcurrent=this->parent();
220           //          debug("newcurrent was .. -> parent="+parent()->name());
221         }
222         else
223         {
224           warning(this->name()+" has no child '"+newcurrentname+"'",
225               "Hierarchy::child");
226           return this;
227         }
228       }
229       //      debug("recurrence call for "+newpath+" on "+newcurrent->name(),"Hie
      rarchy::child");
230       return newcurrent -> child ( newpath );
231     }
232   }
233 }
\end{DoxyCode}
\hypertarget{classHierarchy_aa9a76f69e98e052ee1a6e32cea006288}{
\index{ICECALv3@{ICECALv3}!children@{children}}
\index{children@{children}!ICECALv3@{ICECALv3}}
\subsubsection[{children}]{\setlength{\rightskip}{0pt plus 5cm}std::vector$<${\bf Hierarchy}$\ast$$>$ Hierarchy::children ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classHierarchy_aa9a76f69e98e052ee1a6e32cea006288}


Definition at line 33 of file Hierarchy.h.

References Hierarchy::m\_\-children.

Referenced by Hierarchy::child(), Hierarchy::childTyped(), export\_\-obj(), SpecsSlave::recursiveInitCommunications(), Element::recursiveInitCommunications(), Element::recursiveInitElement(), Application::setConfig(), and Hierarchy::tree().


\begin{DoxyCode}
33 { return m_children;  } //< get list of child(ren)
\end{DoxyCode}
\hypertarget{classHierarchy_a0c15a5276a3b80b4354d6bd8a01e0708}{
\index{ICECALv3@{ICECALv3}!childTyped@{childTyped}}
\index{childTyped@{childTyped}!ICECALv3@{ICECALv3}}
\subsubsection[{childTyped}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Hierarchy} $\ast$ Hierarchy::childTyped (std::string {\em path})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_a0c15a5276a3b80b4354d6bd8a01e0708}


Definition at line 239 of file Hierarchy.cpp.

References Hierarchy::children(), Hierarchy::m\_\-origin, Object::name(), Hierarchy::parent(), and Object::warning().

Referenced by export\_\-obj().


\begin{DoxyCode}
239                                               {
240 
241   std::string newpath = path;
242 
243   std::string up("..");
244   std::string separator(1,'/');
245   std::string typeopen(1,'[');
246   std::string typeclose(1,']');
247 
248   Hierarchy * newcurrent = 0;
249 
250   unsigned int npos=path.find(separator,0);
251   unsigned int opos=path.find(typeopen,0);
252   if ( npos==std::string::npos || npos == path.size()-1 ){
253     if ( path.compare("..")==0 ) {
254       return parent();
255     }
256 
257     if ( npos == path.size()-1 ) {
258       newpath = std::string(path,0,opos);
259       path = newpath;
260     }
261 
262     std::vector < Hierarchy* > list = children();
263     std::vector < Hierarchy* >::iterator iter;
264     for (iter=list.begin();iter!=list.end();iter++){
265       std::string notypepath = std::string(path,0,opos);
266       if ((*iter)->name().compare(notypepath)==0){
267         return *iter;
268       }
269     }
270     warning(this->name()+std::string(" has no child ") +path,"Hierarchy::child");
      
271     return 0;
272   }
273 
274   else {
275 
276     if (std::string(path,0,3).compare(std::string("../"))==0) {
277       newpath=std::string(path,3,path.size()-3);
278       newcurrent = parent();
279     }
280     if (std::string(path,0,1).compare(std::string("/"))==0) {
281       newpath=std::string(path,1,path.size()-1);
282       newcurrent = ( Hierarchy* ) m_origin;
283     }
284     if ((std::string(path,0,3).compare(std::string("../")) !=0 ) &&
285         std::string(path,0,1).compare(std::string("/"))!=0 ) {
286       opos = path.find(typeopen,0);
287       int cpos = path.find(typeclose,0);
288       std::string name = std::string (path,0,opos);
289       newcurrent = childTyped( name );
290       if (newcurrent ==0){
291         warning(path+": no child found with such a name","Hierarchy::child");
292       }
293       newpath = std::string (path,cpos+2,path.size()-cpos-1);
294     }
295     return newcurrent -> childTyped ( newpath );
296   }
297 }
\end{DoxyCode}
\hypertarget{classHierarchy_af4d43b0765b402670eed2d62c73405af}{
\index{ICECALv3@{ICECALv3}!clear@{clear}}
\index{clear@{clear}!ICECALv3@{ICECALv3}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void Hierarchy::clear ()\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_af4d43b0765b402670eed2d62c73405af}


Definition at line 35 of file Hierarchy.cpp.

References Hierarchy::delChild(), Object::info(), Hierarchy::m\_\-children, and Object::name().

Referenced by export\_\-obj().


\begin{DoxyCode}
35                      {
36   std::vector<Hierarchy*> listlocale;
37   std::vector<Hierarchy*>::iterator iter;
38   info("loop on "+name()+" children.","Hierarchy::clear");
39   for (iter=m_children.begin();iter!=m_children.end();iter++){
40       info("processing "+(*iter)->name()+".","Hierarchy::clear");
41 /*
42       (*iter)->clear();
43 //      this->delChild((*iter));
44       info("obj "+(*iter)->name()+" being cleared.","Hierarchy::clear");
45       delete (*iter);
46       info("Object deleted.","Hierarchy::clear");
47       m_children.erase(iter);
48       info("Object removed from the tree.","Hierarchy::clear");
49 */
50     (*iter)->clear();
51     info("Adding object "+(*iter)->name()+" from the Hierarchy to the list of del
      eted objects.","Hierarchy::clear");
52     listlocale.push_back((*iter));
53   }
54 
55   for (iter=listlocale.begin();iter!=listlocale.end();iter++){
56     info("Removing object "+(*iter)->name()+".","Hierarchy::clear");
57     this->delChild(*iter);
58 //    m_children.erase(iter);
59     delete (*iter);
60   }
61   info("Getting out of "+name());
62 }
\end{DoxyCode}
\hypertarget{classElement_af57444353c1ddf9fa0109801e97debf7}{
\index{ICECALv3@{ICECALv3}!connection@{connection}}
\index{connection@{connection}!ICECALv3@{ICECALv3}}
\subsubsection[{connection}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Hierarchy} $\ast$ Element::connection ()\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classElement_af57444353c1ddf9fa0109801e97debf7}
Get IO interface 

Definition at line 84 of file Element.cpp.

References Element::m\_\-connection, Object::name(), and Object::warning().

Referenced by UsbSpiBus::clockDivider(), export\_\-obj(), UsbSpiBus::read(), UsbI2cBus::read(), IOobject::read(), UsbSpiBus::setClockDivider(), UsbSpiBus::write(), UsbI2cBus::write(), and IOobject::write().


\begin{DoxyCode}
84                               {
85   if (0==m_connection){
86     warning("no connection defined for "+name()+".","Element::connection");
87     return (Hierarchy*)0;
88   }
89   return m_connection;
90 }
\end{DoxyCode}
\hypertarget{classObject_a6c9a0397ca804e04d675ed05683f5420}{
\index{ICECALv3@{ICECALv3}!debug@{debug}}
\index{debug@{debug}!ICECALv3@{ICECALv3}}
\subsubsection[{debug}]{\setlength{\rightskip}{0pt plus 5cm}void Object::debug (std::string {\em mymsg}, \/  std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a6c9a0397ca804e04d675ed05683f5420}


Definition at line 45 of file Object.h.

References MsgSvc::DEBUG, Object::m\_\-log, and MsgSvc::msgSvc().


\begin{DoxyCode}
45 { m_log.msgSvc (MsgSvc::DEBUG   , mymsg, name ); }
\end{DoxyCode}
\hypertarget{classObject_aac010553f022165573714b7014a15f0d}{
\index{ICECALv3@{ICECALv3}!debug@{debug}}
\index{debug@{debug}!ICECALv3@{ICECALv3}}
\subsubsection[{debug}]{\setlength{\rightskip}{0pt plus 5cm}void Object::debug (std::string {\em mymsg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_aac010553f022165573714b7014a15f0d}


Definition at line 37 of file Object.h.

References MsgSvc::DEBUG, Object::m\_\-log, Object::m\_\-name, and MsgSvc::msgSvc().

Referenced by A3PE::A3PE(), A3PE::acquisition(), SpecsMezzanine::addBus(), Hierarchy::addChild(), SpecsSlave::addI2c(), LSDelayChipV1::checkConfigAddr(), LSDelayChipV1::checkStatusAddr(), LSDelayChipV1::configRegBulkRead(), LSDelayChipV1::configRegBulkWrite(), A3PE::dataReady(), DCU::DCU(), Hierarchy::delChild(), SpecsSlave::detect(), EmulateFE::execute(), StorageFifoAcquisition::execute(), StorageFifo::execute(), Acquisition::execute(), A3PE\_\-BitFlip::execute(), export\_\-obj(), FePGA::FePGA(), SpecsGlue::i2cClkMode(), SeqPGA::i2cRead(), FePGA::i2cRead(), SeqPGA::i2cWrite(), FePGA::i2cWrite(), ICECALv3(), ICPhaser::ICPhaser(), SpecsSlave::init(), SpecsMaster::init(), EmulateFE::initialize(), StorageFifoAcquisition::initialize(), StorageFifo::initialize(), Acquisition::initialize(), A3PE\_\-BitFlip::initialize(), A3PE::internalAXSequence(), SpecsMezzanine::led(), SpecsGlue::led(), LSDelayChipV1::LSDelayChipV1(), MSOxxxx::MSOxxxx(), Phaser::Phaser(), Data::purge(), ICPhaser::read(), Phaser::read(), FEB\_\-v1::readFifoSpyFE(), SpecsSlave::reset(), SpecsMaster::reset(), FEB\_\-v1::reset(), CU\_\-v1::reset(), Proto40MHz\_\-v1::reset(), FEB\_\-v1::resetFifoSpyFE(), SeqPGA::resetSpi(), FEB\_\-v1::resetSpi(), SeqPGA::SeqPGA(), A3PE::setAddFromAXRam(), A3PE::setAddToAXRam(), A3PE::setAXRamUsb(), Element::setConnection(), SpecsGlue::setI2cClkMode(), A3PE::setLatencyAX(), SpecsMezzanine::setLed(), SpecsGlue::setLed(), A3PE::setLengthAX(), A3PE::setReadToAXRamUsb(), SpecsMaster::setSpeed(), A3PE::setWriteFromAXRamUsb(), SpecsBus::SpecsBus(), SpecsI2c::SpecsI2c(), SpecsMaster::SpecsMaster(), SpecsMezzanine::SpecsMezzanine(), SpecsParallelBus::SpecsParallelBus(), SpecsSlave::SpecsSlave(), LSDelayChipV1::spiBERTest(), spiRead(), spiWrite(), FEB\_\-v1::testDuration(), SeqPGA::testSequence(), A3PE::trigger(), Server::updateConfig(), Server::updateState(), ICPhaser::write(), Phaser::write(), and Hierarchy::$\sim$Hierarchy().


\begin{DoxyCode}
37 { m_log.msgSvc (MsgSvc::DEBUG   , mymsg, m_name ); }
\end{DoxyCode}
\hypertarget{classHierarchy_a1928ac7615fe0b5e55cd707f70dc6781}{
\index{ICECALv3@{ICECALv3}!delChild@{delChild}}
\index{delChild@{delChild}!ICECALv3@{ICECALv3}}
\subsubsection[{delChild}]{\setlength{\rightskip}{0pt plus 5cm}void Hierarchy::delChild (std::string {\em n})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_a1928ac7615fe0b5e55cd707f70dc6781}


Definition at line 110 of file Hierarchy.cpp.

References Object::debug(), and Hierarchy::m\_\-children.


\begin{DoxyCode}
110                                    {
111   bool flag=false;
112   std::vector<Hierarchy*>::iterator iter,remove;
113   for (iter=m_children.begin();iter!=m_children.end();iter++){
114     if ((*iter)->name()==n){ remove=iter; flag=true;}
115   }
116   if (flag){
117     debug("removing "+(*remove)->name()+" from the tree.","Hierarchy::delChild");
      
118     m_children.erase(remove);
119   }
120 }
\end{DoxyCode}
\hypertarget{classHierarchy_a2b2b359fac003233f65786a616766bde}{
\index{ICECALv3@{ICECALv3}!delChild@{delChild}}
\index{delChild@{delChild}!ICECALv3@{ICECALv3}}
\subsubsection[{delChild}]{\setlength{\rightskip}{0pt plus 5cm}void Hierarchy::delChild ({\bf Hierarchy} $\ast$ {\em element})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_a2b2b359fac003233f65786a616766bde}


Definition at line 92 of file Hierarchy.cpp.

References Object::debug(), and Hierarchy::m\_\-children.

Referenced by Hierarchy::clear(), export\_\-obj(), and Hierarchy::$\sim$Hierarchy().


\begin{DoxyCode}
92                                           {
93   bool flag=false;
94   std::vector<Hierarchy*>::iterator iter,remove;
95   for (iter=m_children.begin();(iter!=m_children.end());iter++){
96     if (*iter==element){
97       remove=iter;
98       flag=true;
99     }
100   }
101   if (flag){
102     debug("removing "+(*remove)->name()+" from the tree.","Hierarchy::delChild");
      
103     m_children.erase(remove);
104   }
105 }
\end{DoxyCode}
\hypertarget{classObject_a2e3947f2870094c332d7454117f3ec63}{
\index{ICECALv3@{ICECALv3}!dllName@{dllName}}
\index{dllName@{dllName}!ICECALv3@{ICECALv3}}
\subsubsection[{dllName}]{\setlength{\rightskip}{0pt plus 5cm}std::string Object::dllName ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a2e3947f2870094c332d7454117f3ec63}
Get accessor to member m\_\-dllName \begin{DoxyReturn}{Returns}
the current value of m\_\-dllName 
\end{DoxyReturn}


Definition at line 74 of file Object.h.

References Object::m\_\-dllName.

Referenced by export\_\-obj().


\begin{DoxyCode}
74                        {
75     return m_dllName;
76   }  
\end{DoxyCode}
\hypertarget{classICECALv3_ac26be912fb72e615106fceb4626aa548}{
\index{ICECALv3@{ICECALv3}!dumpConfig@{dumpConfig}}
\index{dumpConfig@{dumpConfig}!ICECALv3@{ICECALv3}}
\subsubsection[{dumpConfig}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StatusCode} ICECALv3::dumpConfig (string {\em configFile}, \/  PyObject $\ast$ {\em chipId})}}
\label{classICECALv3_ac26be912fb72e615106fceb4626aa548}


Definition at line 132 of file ICECALv3.cpp.

References StatusCode::FAILURE, getAnalogCh(), getDelayLineCh(), getMainReg(), StatusCode::SUCCESS, and writeAsicParams().

Referenced by BOOST\_\-PYTHON\_\-MODULE().


\begin{DoxyCode}
133 {
134     PyObject* asicParams = PyList_New(0);
135     bool ok;
136 
137     //The first list item is the Chip Identifier.
138     PyList_Append(asicParams, chipId);
139 
140     //Let's ask for the configuration to our chip.
141     //Each function will return the corresponding parameter list
142     //of that register.
143     for(int i=0;i<4;i++)
144     {
145         PyList_Append(asicParams, getDelayLineCh(i) );
146         PyList_Append(asicParams, getAnalogCh(i) );
147     }
148     PyList_Append(asicParams, getMainReg() );
149 
150     ok = writeAsicParams(configFile,asicParams);
151 
152     if(ok) return StatusCode::SUCCESS;
153     else   return StatusCode::FAILURE;
154 }
\end{DoxyCode}
\hypertarget{classObject_ad7f6c457733082efa2f9ff5f5c8e119a}{
\index{ICECALv3@{ICECALv3}!error@{error}}
\index{error@{error}!ICECALv3@{ICECALv3}}
\subsubsection[{error}]{\setlength{\rightskip}{0pt plus 5cm}void Object::error (std::string {\em mymsg}, \/  std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_ad7f6c457733082efa2f9ff5f5c8e119a}


Definition at line 48 of file Object.h.

References MsgSvc::ERR, Object::m\_\-log, and MsgSvc::msgSvc().


\begin{DoxyCode}
48 { m_log.msgSvc (MsgSvc::ERR     , mymsg, name ); }
\end{DoxyCode}
\hypertarget{classObject_a204a95f57818c0f811933917a30eff45}{
\index{ICECALv3@{ICECALv3}!error@{error}}
\index{error@{error}!ICECALv3@{ICECALv3}}
\subsubsection[{error}]{\setlength{\rightskip}{0pt plus 5cm}void Object::error (std::string {\em mymsg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a204a95f57818c0f811933917a30eff45}


Definition at line 40 of file Object.h.

References MsgSvc::ERR, Object::m\_\-log, Object::m\_\-name, and MsgSvc::msgSvc().

Referenced by checkChNumber(), A3PE::clockDivision(), NI6008::cmd(), A3PE::enableStorage(), A3PE\_\-BitFlip::execute(), export\_\-obj(), A3PE::fifoDepth(), A3PE::fifoLatency(), FEB\_\-v1::gbtStatus(), Register::getBit(), MSOxxxx::getStatistics(), SpecsMaster::init(), NI6008::init(), UsbFTMLInterface::init(), UsbFTInterface::init(), A3PE::latencyAX(), A3PE::lengthAX(), A3PE::nTrigger(), MSOxxxx::open(), parseParameterList(), A3PE::pipeline(), UsbFTMLInterface::read(), UsbFTInterface::read(), MSOxxxx::recv(), A3PE::reset(), MSOxxxx::send(), A3PE::setAddFromAXRam(), A3PE::setAddToAXRam(), setAnalogCh(), A3PE::setAXRamUsb(), Register::setBit(), A3PE::setClockDivision(), A3PE::setFifoDepth(), A3PE::setFifoLatency(), A3PE::setLatencyAX(), A3PE::setLengthAX(), A3PE::setNTrigger(), A3PE::setPipeline(), A3PE::setReadPatternFifoUsb(), A3PE::setReadToAXRamUsb(), A3PE::setReadTriggerFifoUsb(), A3PE::setSoftwareTrigger(), A3PE::setTriggerDelay(), A3PE::setTriggerRate(), A3PE::setWriteFromAXRamUsb(), A3PE::setWriteStorageFifoUsb(), spiFERTest(), spiWriteSafe(), A3PE::startSequenceAX(), A3PE::triggerDelay(), A3PE::triggerRate(), UsbFTMLInterface::usbRead(), UsbFTInterface::usbRead(), UsbFTMLInterface::usbReadU16(), UsbFTInterface::usbReadU16(), UsbFTMLInterface::usbReadU32(), UsbFTInterface::usbReadU32(), UsbFTMLInterface::usbReadU8(), UsbFTInterface::usbReadU8(), UsbFTMLInterface::usbWrite(), UsbFTInterface::usbWrite(), UsbFTMLInterface::usbWriteRead(), UsbFTInterface::usbWriteRead(), UsbFTMLInterface::usbWriteU16(), UsbFTInterface::usbWriteU16(), UsbFTMLInterface::usbWriteU32(), UsbFTInterface::usbWriteU32(), UsbFTMLInterface::usbWriteU8(), UsbFTInterface::usbWriteU8(), UsbFTMLInterface::write(), and UsbFTInterface::write().


\begin{DoxyCode}
40 { m_log.msgSvc (MsgSvc::ERR     , mymsg, m_name ); }
\end{DoxyCode}
\hypertarget{classObject_ae62acd3d09f716220f75f252dc38bc9a}{
\index{ICECALv3@{ICECALv3}!fatal@{fatal}}
\index{fatal@{fatal}!ICECALv3@{ICECALv3}}
\subsubsection[{fatal}]{\setlength{\rightskip}{0pt plus 5cm}void Object::fatal (std::string {\em mymsg}, \/  std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_ae62acd3d09f716220f75f252dc38bc9a}


Definition at line 49 of file Object.h.

References MsgSvc::FATAL, Object::m\_\-log, and MsgSvc::msgSvc().


\begin{DoxyCode}
49 { m_log.msgSvc (MsgSvc::FATAL   , mymsg, name ); }
\end{DoxyCode}
\hypertarget{classObject_aad5a16aac7516ce65bd5ec02ab07fc80}{
\index{ICECALv3@{ICECALv3}!fatal@{fatal}}
\index{fatal@{fatal}!ICECALv3@{ICECALv3}}
\subsubsection[{fatal}]{\setlength{\rightskip}{0pt plus 5cm}void Object::fatal (std::string {\em mymsg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_aad5a16aac7516ce65bd5ec02ab07fc80}


Definition at line 41 of file Object.h.

References MsgSvc::FATAL, Object::m\_\-log, Object::m\_\-name, and MsgSvc::msgSvc().

Referenced by export\_\-obj(), SpecsSlave::init(), UsbSpiBus::init(), UsbI2cBus::init(), IOobject::init(), UsbMLSpiBus::init(), UsbMLI2cBus::init(), UsbFTMLInterface::init(), UsbFTInterface::init(), and Element::setConnection().


\begin{DoxyCode}
41 { m_log.msgSvc (MsgSvc::FATAL   , mymsg, m_name ); }
\end{DoxyCode}
\hypertarget{classICECALv3_ac006abc42a048308427f6801d783a407}{
\index{ICECALv3@{ICECALv3}!fillParams@{fillParams}}
\index{fillParams@{fillParams}!ICECALv3@{ICECALv3}}
\subsubsection[{fillParams}]{\setlength{\rightskip}{0pt plus 5cm}PyObject $\ast$ ICECALv3::fillParams (string {\em paramListRet}\mbox{[}$\,$\mbox{]}, \/  int {\em paramListLen}, \/  string {\em paramName}\mbox{[}64\mbox{]}, \/  int {\em paramValue}\mbox{[}64\mbox{]}, \/  int {\em fileParamLen})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_ac006abc42a048308427f6801d783a407}


Definition at line 106 of file ICECALv3.cpp.

Referenced by loadConfig().


\begin{DoxyCode}
107 {
108     int iParamFile;
109     bool found;
110     PyObject* asicParams = PyList_New(0);
111 
112     //For each of the parameters of the list...
113     for(int iList=0 ; iList<paramListLen ; iList++)
114     {
115         iParamFile=0;
116         found = false;
117         //We look for the parameter name in the C++ dictionary.
118         while(iParamFile < fileParamLen && !found)
119         {
120             if(paramName[iParamFile].find(paramListRet[iList]) != string::npos)
121             {
122                 PyList_Append(asicParams, PyInt_FromLong(paramValue[iParamFile]))
      ;
123                 found = true;
124             }
125             iParamFile++;
126         }
127     }
128     return asicParams;
129 }
\end{DoxyCode}
\hypertarget{classICECALv3_a5f1414e6049a82eafdd505a88d7d0c91}{
\index{ICECALv3@{ICECALv3}!getAnalogCh@{getAnalogCh}}
\index{getAnalogCh@{getAnalogCh}!ICECALv3@{ICECALv3}}
\subsubsection[{getAnalogCh}]{\setlength{\rightskip}{0pt plus 5cm}PyObject $\ast$ ICECALv3::getAnalogCh (int {\em ch})}}
\label{classICECALv3_a5f1414e6049a82eafdd505a88d7d0c91}


Definition at line 312 of file ICECALv3.cpp.

References err, icecalLSBAddrCh, icecalMSBAddrCh, Object::info(), itohs(), itos(), and spiRead().

Referenced by BOOST\_\-PYTHON\_\-MODULE(), and dumpConfig().


\begin{DoxyCode}
313 {                            
314     U8 spiLsbAddr = icecalLSBAddrCh[ch];            //The SPI address of the 16 L
      SBs.
315     U8 spiMsbAddr = icecalMSBAddrCh[ch];            //The SPI address of the 16 M
      SBs.
316 
317     int cIntMsb, cIntLsb0, cIntLsb1, iOffMsb, cIntSubCh0, cIntSubCh1, iOffLsb0, i
      OffLsb1, iOffSubCh0, iOffSubCh1, zero, pole, zIn;
318     PyObject* icecalChParams = PyList_New(0);
319 
320     //32 bit register from two SPI 16-bit registers.
321     U32 rxData = (spiRead(spiMsbAddr) << 16) | spiRead(spiLsbAddr);
322 
323     if(err) PyList_Append(icecalChParams, PyInt_FromLong(-1));
324     else
325     {
326         cIntMsb     = (rxData >> 30) & 0x03;        //2 bits.
327         cIntLsb0    = (rxData >> 27) & 0x07;        //3 bits.
328         cIntLsb1    = (rxData >> 24) & 0x07;        //3 bits.
329         iOffMsb     = (rxData >> 20) & 0x0F;        //4 bits.
330         iOffLsb0    = (rxData >> 18) & 0x03;        //2 bits.
331         iOffLsb1    = (rxData >> 16) & 0x03;        //2 bits.
332         zero            = (rxData >> 11) & 0x1F;        //5 bits.
333         pole            = (rxData >> 5)  & 0x3F;        //6 bits.
334         zIn             = (rxData)           & 0x1F;        //5 bits.
335 
336         cIntSubCh0 = (cIntMsb << 3) | cIntLsb0;     //cInt: The 2 MSB are shared 
      between subchannels.
337         cIntSubCh1 = (cIntMsb << 3) | cIntLsb1;     //The 3 LSB may differ from s
      ubchannels.
338         iOffSubCh0 = (iOffMsb << 2) | iOffLsb0;     //iOff: 4 common + 2 differen
      t.
339         iOffSubCh1 = (iOffMsb << 2) | iOffLsb1;
340 
341         PyList_Append(icecalChParams, PyInt_FromLong(cIntSubCh0));
342         PyList_Append(icecalChParams, PyInt_FromLong(cIntSubCh1));
343         PyList_Append(icecalChParams, PyInt_FromLong(iOffSubCh0));
344         PyList_Append(icecalChParams, PyInt_FromLong(iOffSubCh1));
345         PyList_Append(icecalChParams, PyInt_FromLong(zero));
346         PyList_Append(icecalChParams, PyInt_FromLong(pole));
347         PyList_Append(icecalChParams, PyInt_FromLong(zIn));
348 
349         info("ICECAL Analog Channel <"+itos(ch)+"> (MSB @SPI = 0x"+itohs(spiMsbAd
      dr)+". LSB @SPI = 0x"+itohs(spiLsbAddr)+"):","ICECALv3::getIcecal");
350         info("   ·Integrator capacitor SubCh<0> : "+itos(cIntSubCh0)   ,"ICECALv
      3::getAnalogCh");
351         info("   ·Integrator capacitor SubCh<1> : "+itos(cIntSubCh1)   ,"ICECALv
      3::getAnalogCh");
352         info("   ·Offset Current SubCh<0>       : "+itos(iOffSubCh0)   ,"ICECALv
      3::getAnalogCh");
353         info("   ·Offset Current SubCh<1>       : "+itos(iOffSubCh1)   ,"ICECALv
      3::getAnalogCh");
354         info("   ·PZ Zero capacitor             : "+itos(zero)             ,"ICE
      CALv3::getAnalogCh");
355         info("   ·PZ Pole capacitor             : "+itos(pole)             ,"ICE
      CALv3::getAnalogCh");
356         info("   ·Input impedance control       : "+itos(zIn)                  ,
      "ICECALv3::getAnalogCh");
357     }
358     return icecalChParams;
359 }
\end{DoxyCode}
\hypertarget{classICECALv3_a7a1c1706a455903f42bb9a5257d94a78}{
\index{ICECALv3@{ICECALv3}!getDelayLineCh@{getDelayLineCh}}
\index{getDelayLineCh@{getDelayLineCh}!ICECALv3@{ICECALv3}}
\subsubsection[{getDelayLineCh}]{\setlength{\rightskip}{0pt plus 5cm}PyObject $\ast$ ICECALv3::getDelayLineCh (int {\em ch})}}
\label{classICECALv3_a7a1c1706a455903f42bb9a5257d94a78}


Definition at line 246 of file ICECALv3.cpp.

References delayLineAddrCh, err, Object::info(), itohs(), itos(), and spiRead().

Referenced by BOOST\_\-PYTHON\_\-MODULE(), and dumpConfig().


\begin{DoxyCode}
247 {                            
248     U8 spiAddr = delayLineAddrCh[ch];           //The SPI address of this delay l
      ine channel.
249     U16 rxData = spiRead(spiAddr);              //rxData contains the 16 bits cor
      responding to the delay line channel.
250 
251     int phaseADC, phaseTH, phaseINT, locSel, lvdsOEn;
252     PyObject* dllParams = PyList_New(0);
253 
254     if(err) PyList_Append(dllParams, PyInt_FromLong(-1));
255     else
256     {
257         phaseADC = (rxData >> 11) & 0x1F;       //5 bits.
258         phaseTH  = (rxData >> 6 ) & 0x1F;       //5 bits.
259         phaseINT = (rxData >> 3 ) & 0x07;       //3 bits.
260         locSel   = (rxData >> 1 ) & 0x03;       //2 bits.
261         lvdsOEn  = (rxData & 0x01);                 //1 bit.
262 
263         //Converts integers to PyInt objects and then appends them to the PyList
264         PyList_Append(dllParams, PyInt_FromLong(phaseADC));
265         PyList_Append(dllParams, PyInt_FromLong(phaseTH));
266         PyList_Append(dllParams, PyInt_FromLong(phaseINT));
267         PyList_Append(dllParams, PyInt_FromLong(locSel));
268         PyList_Append(dllParams, PyInt_FromLong(lvdsOEn));
269 
270         info("Delay Line Channel <"+itos(ch)+"> configuration (@SPI = 0x"+itohs(s
      piAddr)+"):","ICECALv3::getDelayLine");
271         info("   ·Phase ADC          : "+itos(phaseADC),"ICECALv3::getDelayLine"
      );
272         info("   ·Phase T&H          : "+itos(phaseTH) ,"ICECALv3::getDelayLine"
      );
273         info("   ·Phase INT          : "+itos(phaseINT),"ICECALv3::getDelayLine"
      );
274         info("   ·LVDS Current Sel   : "+itos(locSel)  ,"ICECALv3::getDelayLine"
      );
275         info("   ·LVDS Output enable : "+itos(lvdsOEn) ,"ICECALv3::getDelayLine"
      );
276     }
277     return dllParams;
278 }
\end{DoxyCode}
\hypertarget{classICECALv3_a4a414d23c1e199b446dc876161338148}{
\index{ICECALv3@{ICECALv3}!getMainReg@{getMainReg}}
\index{getMainReg@{getMainReg}!ICECALv3@{ICECALv3}}
\subsubsection[{getMainReg}]{\setlength{\rightskip}{0pt plus 5cm}PyObject $\ast$ ICECALv3::getMainReg ()}}
\label{classICECALv3_a4a414d23c1e199b446dc876161338148}


Definition at line 415 of file ICECALv3.cpp.

References err, icecalMainAddr, Object::info(), itohs(), itos(), and spiRead().

Referenced by BOOST\_\-PYTHON\_\-MODULE(), and dumpConfig().


\begin{DoxyCode}
416 {                            
417     U16 rxD[4];
418 
419     int vCtlOE, bxidSynOE, clkRefreshEn, iBiasOB, iBiasCETH, iBiasTH, iBiasINT;
420     int iBiasCEINT, iBiasCEPZ, iBias0T, iBiasPZ, iBiasV0T;
421     PyObject* icecalMainParams = PyList_New(0);
422 
423     for(int i=0;i<4;i++) rxD[i] = spiRead(icecalMainAddr[i]);       //4 registers
       of 16 bits.
424 
425     if(err) PyList_Append(icecalMainParams, PyInt_FromLong(-1));
426     else
427     {
428         //Delay Line & Slow Control main configuration bits.
429         vCtlOE              = !((rxD[3] >> 15) & 0x01);     //1 bit (active low) 
      (d63).
430         bxidSynOE           = !((rxD[3] >> 14) & 0x01);     //1 bit (active low) 
      (d62).
431         clkRefreshEn    = !((rxD[3] >> 13) & 0x01);     //1 bit (active low) (d61
      ).
432 
433         //Bias currents for the analog channels.
434         iBiasOB             = (rxD[3] >> 6) & 0x3F;     //6 bits (d59..54).
435         iBiasCETH           = (rxD[3])          & 0x3F;     //6 bits (d53..48).
436         iBiasTH             = (rxD[2] >> 6) & 0x3F;     //6 bits (d43..38).
437         iBiasINT            = (rxD[2] )         & 0x3F;     //6 bits (d37..32).
438         iBiasCEINT      =((rxD[1] >> 9) & 0x38) | ((rxD[0] >> 12) & 0x7);       /
      /6 bits (d30..28, d14..12).
439         iBiasCEPZ           = (rxD[1] >> 6) & 0x3F;     //6 bits (d27..22).
440         iBias0T             = (rxD[1])          & 0x3F;     //6 bits (d21..16).
441         iBiasPZ             = (rxD[0] >> 6) & 0x3F;     //6 bits (d11..06).
442         iBiasV0T            = (rxD[0])          & 0x3F;     //6 bits (d05..00).
443 
444         PyList_Append(icecalMainParams, PyInt_FromLong(vCtlOE));
445         PyList_Append(icecalMainParams, PyInt_FromLong(bxidSynOE));
446         PyList_Append(icecalMainParams, PyInt_FromLong(clkRefreshEn));
447         PyList_Append(icecalMainParams, PyInt_FromLong(iBiasOB));
448         PyList_Append(icecalMainParams, PyInt_FromLong(iBiasCETH));
449         PyList_Append(icecalMainParams, PyInt_FromLong(iBiasTH));
450         PyList_Append(icecalMainParams, PyInt_FromLong(iBiasINT));
451         PyList_Append(icecalMainParams, PyInt_FromLong(iBiasCEINT));
452         PyList_Append(icecalMainParams, PyInt_FromLong(iBiasCEPZ));
453         PyList_Append(icecalMainParams, PyInt_FromLong(iBias0T));
454         PyList_Append(icecalMainParams, PyInt_FromLong(iBiasPZ));
455         PyList_Append(icecalMainParams, PyInt_FromLong(iBiasV0T));
456 
457         info("ICECAL Main Register (@SPI = [0x"+itohs(icecalMainAddr[3])+"..0x"+
      itohs(icecalMainAddr[0])+"]):","ICECALv3::getIcecalMain");
458         info("   ·DLL Control Voltage Output Enable: " + itos(vCtlOE)              ,
      "ICECALv3::getIcecalMain");
459         info("   ·BXID Resynch Output Enable       : " + itos(bxidSynOE)       ,
      "ICECALv3::getIcecalMain");
460         info("   ·SPI Clock refresh Enable         : " + itos(clkRefreshEn) ,"IC
      ECALv3::getIcecalMain");
461         info("   ·Output Buffer bias               : " + itos(iBiasOB)         ,
      "ICECALv3::getIcecalMain");
462         info("   ·Track & Hold OpAmp bias (CE)     : " + itos(iBiasCETH)       ,
      "ICECALv3::getIcecalMain");
463         info("   ·Track & Hold OpAmp bias          : " + itos(iBiasTH)         ,
      "ICECALv3::getIcecalMain");
464         info("   ·Integrator OpAmp bias            : " + itos(iBiasINT)            ,
      "ICECALv3::getIcecalMain");
465         info("   ·Integrator OpAmp bias (CE)       : " + itos(iBiasCEINT)      ,
      "ICECALv3::getIcecalMain");
466         info("   ·Pole-Zero OpAmp bias (CE)        : " + itos(iBiasCEPZ)       ,
      "ICECALv3::getIcecalMain");
467         info("   ·0T bias                   : " + itos(iBias0T)            ,"ICE
      CALv3::getIcecalMain");
468         info("   ·Pole-Zero OpAmp bias             : " + itos(iBiasPZ)         ,
      "ICECALv3::getIcecalMain");
469         info("   ·0T bias (V0T)             : " + itos(iBiasV0T)           ,"ICE
      CALv3::getIcecalMain");
470     }
471     return icecalMainParams;
472 }
\end{DoxyCode}
\hypertarget{classHierarchy_a255174fe4d316d2a3f430dcb9dab29f1}{
\index{ICECALv3@{ICECALv3}!hasChildren@{hasChildren}}
\index{hasChildren@{hasChildren}!ICECALv3@{ICECALv3}}
\subsubsection[{hasChildren}]{\setlength{\rightskip}{0pt plus 5cm}bool Hierarchy::hasChildren ()\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_a255174fe4d316d2a3f430dcb9dab29f1}


Definition at line 303 of file Hierarchy.cpp.

References Hierarchy::m\_\-children.

Referenced by export\_\-obj().


\begin{DoxyCode}
303                               {
304   return ( m_children.size()>0 );
305 }
\end{DoxyCode}
\hypertarget{classICECALv3_a00e572849b4952e7cf04a39f992df037}{
\index{ICECALv3@{ICECALv3}!help@{help}}
\index{help@{help}!ICECALv3@{ICECALv3}}
\subsubsection[{help}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::help ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classICECALv3_a00e572849b4952e7cf04a39f992df037}
printout help for the \hyperlink{namespaceelement}{element} 

Implements \hyperlink{classElement_a32c0de27acb08e17251cef88c3e9303a}{Element}.

Definition at line 104 of file ICECALv3.h.

References Object::info(), and Object::name().


\begin{DoxyCode}
104 { info("ICECALv3 "+name()+". No help.","ICECALv3::help"); };
\end{DoxyCode}
\hypertarget{classObject_af99145335cc61ff6e2798ea17db009d2}{
\index{ICECALv3@{ICECALv3}!id@{id}}
\index{id@{id}!ICECALv3@{ICECALv3}}
\subsubsection[{id}]{\setlength{\rightskip}{0pt plus 5cm}unsigned char Object::id ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_af99145335cc61ff6e2798ea17db009d2}


Reimplemented in \hyperlink{classMSOxxxx_a0f14b23d31d8e7647184e99a89600cc3}{MSOxxxx}.

Definition at line 30 of file Object.h.

References Object::m\_\-id.

Referenced by export\_\-obj().


\begin{DoxyCode}
30 { return m_id;         } //< Get Object m_id 
\end{DoxyCode}
\hypertarget{classObject_a1ca123253dfd30fc28b156f521dcbdae}{
\index{ICECALv3@{ICECALv3}!info@{info}}
\index{info@{info}!ICECALv3@{ICECALv3}}
\subsubsection[{info}]{\setlength{\rightskip}{0pt plus 5cm}void Object::info (std::string {\em mymsg}, \/  std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a1ca123253dfd30fc28b156f521dcbdae}


Definition at line 46 of file Object.h.

References MsgSvc::INFO, Object::m\_\-log, and MsgSvc::msgSvc().


\begin{DoxyCode}
46 { m_log.msgSvc (MsgSvc::INFO    , mymsg, name ); }
\end{DoxyCode}
\hypertarget{classObject_a644fd329ea4cb85f54fa6846484b84a8}{
\index{ICECALv3@{ICECALv3}!info@{info}}
\index{info@{info}!ICECALv3@{ICECALv3}}
\subsubsection[{info}]{\setlength{\rightskip}{0pt plus 5cm}void Object::info (std::string {\em mymsg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a644fd329ea4cb85f54fa6846484b84a8}


Definition at line 38 of file Object.h.

References MsgSvc::INFO, Object::m\_\-log, Object::m\_\-name, and MsgSvc::msgSvc().

Referenced by NI6008::addDevice(), bxidResynchStatus(), FEB\_\-v1::calibCte(), checkCmd(), Hierarchy::clear(), FEB\_\-v1::clock80MHzFallingEdge(), FEB\_\-v1::clockFallingEdge(), UsbFTMLInterface::close(), UsbFTInterface::close(), MSOxxxx::closeConnection(), Processus::closeRootFile(), SpecsMezzanine::cmdline(), Server::cmdline(), SpecsSlave::detect(), FEB\_\-v1::disableSubtract(), IOdata::dump(), A3PE::dumpFromAX(), A3PE::dumpPattern(), A3PE::dumpStorage(), A3PE::dumpToAX(), A3PE::dumpTrigger(), Processus::endProcessing(), PhaserRampExec::execute(), export\_\-obj(), PhaserRampExec::finalize(), FEB\_\-v1::gain4(), FEB\_\-v1::gbt80MHzClkEport(), FEB\_\-v1::gbtDataPath(), FEB\_\-v1::gbtDLLEport(), FEB\_\-v1::gbtDLLReset(), FEB\_\-v1::gbtEnableEport(), FEB\_\-v1::gbtMode(), FEB\_\-v1::gbtStatus(), FEB\_\-v1::gbtTermEport(), FEB\_\-v1::gbtTrackMode(), getAnalogCh(), getDelayLineCh(), getMainReg(), FEB\_\-v1::globalPseudoPMEnable(), SpecsMezzanine::help(), SpecsMaster::help(), SpecsGlue::help(), SpecsParallelBus::help(), SpecsInterface::help(), NI6008::help(), Computer::help(), UsbSpiBus::help(), UsbI2cBus::help(), RAM::help(), IOobject::help(), UsbMLSpiBus::help(), UsbMLI2cBus::help(), UsbFTMLInterface::help(), SeqPGA::help(), ICPhaser::help(), FePGA::help(), FEB\_\-v1::help(), CU\_\-v1::help(), UsbFTInterface::help(), Proto40MHz\_\-v1::help(), A3PE::help(), Phaser::help(), Croc::help(), MSOxxxx::help(), LSDelayChipV1::help(), help(), MSOxxxx::id(), SpecsSlave::init(), SpecsMaster::init(), SpecsParallelBus::init(), SpecsInterface::init(), NI6008::init(), Computer::init(), UsbFTMLInterface::init(), UsbFTInterface::init(), Croc::init(), CurrentMeasurement::initialize(), ADCMeasurement::initialize(), EmulateFE::initialize(), StorageFifoAcquisition::initialize(), StorageFifo::initialize(), Acquisition::initialize(), A3PE\_\-BitFlip::initialize(), PhaserRampExec::initialize(), FEB\_\-v1::injectModeFE(), isInt(), FEB\_\-v1::latency(), FEB\_\-v1::latencyLLT(), A3PE::loadFromAX(), Application::loadHistoryFile(), A3PE::loadPattern(), A3PE::loadStorage(), A3PE::loadToAX(), A3PE::loadTrigger(), Application::loop(), FEB\_\-v1::maskLLT(), Application::network(), FEB\_\-v1::oldSubtract(), MSOxxxx::open(), Processus::openRootFile(), Data::print(), FEB\_\-v1::probeEnable(), ProcDataBase::ProcDataBase(), FEB\_\-v1::pseudoADCEnable(), FEB\_\-v1::pseudoPMEnable(), UsbSpiBus::read(), UsbFTMLInterface::read(), FEB\_\-v1::readFifoInjectFE(), FEB\_\-v1::readFifoLLT(), FEB\_\-v1::readFifoLLTFE(), FEB\_\-v1::readFifoSpyFE(), MSOxxxx::recv(), SpecsMaster::reset(), SpecsParallelBus::reset(), SpecsInterface::reset(), NI6008::reset(), Computer::reset(), UsbSpiBus::reset(), UsbI2cBus::reset(), UsbMLSpiBus::reset(), UsbMLI2cBus::reset(), UsbFTMLInterface::reset(), SeqPGA::reset(), FePGA::reset(), UsbFTInterface::reset(), A3PE::reset(), Croc::reset(), A3PE::resetAcquisitionWriteCounter(), FEB\_\-v1::resetFE(), A3PE::resetFE(), FEB\_\-v1::resetFifoInjectFE(), A3PE::resetFromAXRam(), SpecsSlave::resetInternal(), A3PE::resetLatencyCounter(), A3PE::resetPatternFifo(), A3PE::resetSequenceFromToAX(), A3PE::resetSPI(), A3PE::resetStorageFifo(), A3PE::resetToAXRam(), A3PE::resetTriggerFifo(), FePGA::resetUsb(), A3PE::resetUsbPhasers(), MSOxxxx::send(), Server::Server(), Application::server(), FEB\_\-v1::setCalibCte(), FEB\_\-v1::setClock80MHzFallingEdge(), A3PE::setClockDivision(), FEB\_\-v1::setClockFallingEdge(), UsbSpiBus::setDataLength(), FEB\_\-v1::setDisableSubtract(), A3PE::setEnableADC(), A3PE::setFifoDepth(), A3PE::setFifoLatency(), FEB\_\-v1::setGain4(), FEB\_\-v1::setGbt80MHzClkEport(), FEB\_\-v1::setGbtClockStrength(), FEB\_\-v1::setGbtDataPath(), FEB\_\-v1::setGbtDLLEport(), FEB\_\-v1::setGbtEnableEport(), FEB\_\-v1::setGbtMode(), FEB\_\-v1::setGbtTermEport(), FEB\_\-v1::setGbtTrackMode(), FEB\_\-v1::setGlobalPseudoPMEnable(), FEB\_\-v1::setInjectModeFE(), A3PE::setInternalAXSequence(), FEB\_\-v1::setLatency(), A3PE::setNTrigger(), FEB\_\-v1::setOldSubtract(), FEB\_\-v1::setOutputEport(), ICPhaser::setPhase(), Phaser::setPhase(), A3PE::setPipeline(), FEB\_\-v1::setProbeEnable(), FEB\_\-v1::setPseudoADCEnable(), FEB\_\-v1::setPseudoPMEnable(), A3PE::setReadPatternFifoUsb(), A3PE::setReadTriggerFifoUsb(), A3PE::setSoftwareTrigger(), FEB\_\-v1::setSpareForTrigEnable(), FEB\_\-v1::setSpyModeFE(), FEB\_\-v1::setThreshold(), A3PE::setTriggerDelay(), A3PE::setTriggerRate(), A3PE::setWriteStorageFifoUsb(), LSDelayChipV1::showConfig(), FEB\_\-v1::spareForTrigEnable(), SpecsI2c::SpecsI2c(), spiFERTest(), FEB\_\-v1::spyModeFE(), FEB\_\-v1::spyModeSeq(), Server::start(), Processus::startProcessing(), FEB\_\-v1::statusRegister(), FEB\_\-v1::stopInjLoop(), Application::svcRunning(), Application::terminate(), FePGA::testSequence(), FEB\_\-v1::threshold(), Hierarchy::tree(), SpecsParallelBus::update(), SpecsInterface::update(), NI6008::update(), Computer::update(), UsbSpiBus::update(), UsbI2cBus::update(), UsbMLSpiBus::update(), UsbMLI2cBus::update(), UsbFTMLInterface::update(), FEB\_\-v1::update(), CU\_\-v1::update(), UsbFTInterface::update(), Proto40MHz\_\-v1::update(), Croc::update(), UsbFTInterface::UsbFTInterface(), UsbFTMLInterface::UsbFTMLInterface(), version(), UsbSpiBus::write(), FEB\_\-v1::writeDataFifoInjectFE(), FEB\_\-v1::writeFifoInjectFE(), and NI6008::$\sim$NI6008().


\begin{DoxyCode}
38 { m_log.msgSvc (MsgSvc::INFO    , mymsg, m_name ); }
\end{DoxyCode}
\hypertarget{classICECALv3_abf7281fad80b80b70c5b13ce66ba3451}{
\index{ICECALv3@{ICECALv3}!init@{init}}
\index{init@{init}!ICECALv3@{ICECALv3}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StatusCode} ICECALv3::init ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classICECALv3_abf7281fad80b80b70c5b13ce66ba3451}
init the component

\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}


Implements \hyperlink{classElement_af42754b5cabc198869222725218d695c}{Element}.

Definition at line 111 of file ICECALv3.h.

References StatusCode::SUCCESS.


\begin{DoxyCode}
111                     {
112     return StatusCode::SUCCESS;
113   };
\end{DoxyCode}
\hypertarget{classAttrib_a704f26af560909ad22065083bb7d4c34}{
\index{ICECALv3@{ICECALv3}!is@{is}}
\index{is@{is}!ICECALv3@{ICECALv3}}
\subsubsection[{is}]{\setlength{\rightskip}{0pt plus 5cm}bool Attrib::is (int {\em attribut})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classAttrib_a704f26af560909ad22065083bb7d4c34}
Test for an attribut 

Definition at line 50 of file Attrib.h.

References Attrib::m\_\-attributs.

Referenced by export\_\-obj(), and Element::setConnection().


\begin{DoxyCode}
51   {
52     std::vector<int>::const_iterator iter ;
53     for ( iter  = m_attributs.begin() ;
54           iter != m_attributs.end()   ;
55           ++iter ) {
56       if ( attribut == (*iter) ) {
57         return true;
58       }
59     }
60     return false;
61   }
\end{DoxyCode}
\hypertarget{classICECALv3_a04b02e583f191bfce34d05132cd23834}{
\index{ICECALv3@{ICECALv3}!itohs@{itohs}}
\index{itohs@{itohs}!ICECALv3@{ICECALv3}}
\subsubsection[{itohs}]{\setlength{\rightskip}{0pt plus 5cm}std::string ICECALv3::itohs (int {\em value})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classICECALv3_a04b02e583f191bfce34d05132cd23834}


Definition at line 164 of file ICECALv3.h.

Referenced by bxidResynchStatus(), getAnalogCh(), getDelayLineCh(), getMainReg(), setAnalogCh(), spiAddressScan(), spiFERTest(), spiRead(), spiWrite(), and spiWriteSafe().


\begin{DoxyCode}
165     {
166         char buff[32];
167       if      (value < 256)   sprintf(buff,"%02X",value);
168         else if (value < 65536) sprintf(buff,"%04X",value);
169         else                                    sprintf(buff,"%08X",value);
170         return std::string(buff);
171     }
\end{DoxyCode}
\hypertarget{classICECALv3_a514456dd303e897aa1b55dccf3fa66d0}{
\index{ICECALv3@{ICECALv3}!loadConfig@{loadConfig}}
\index{loadConfig@{loadConfig}!ICECALv3@{ICECALv3}}
\subsubsection[{loadConfig}]{\setlength{\rightskip}{0pt plus 5cm}PyObject $\ast$ ICECALv3::loadConfig (string {\em configFile})}}
\label{classICECALv3_a514456dd303e897aa1b55dccf3fa66d0}


Definition at line 36 of file ICECALv3.cpp.

References fillParams(), parseParameterList(), setAnalogCh(), setDelayLineCh(), and setMainReg().

Referenced by BOOST\_\-PYTHON\_\-MODULE().


\begin{DoxyCode}
37 {
38     string paramName[64];
39     int paramValue[64], nParams;
40     PyObject* asicParams;
41 
42     PyObject* fullConfiguration = PyList_New(0);
43     //These are the names of the parameters that we are looking for in each case.
      
44     string mainParams[] = {"VCONTROL_OE","BXID_SYN_OE","CLK_REFRESH","IBIAS_OB","
      IBIAS_CE_TH","IBIAS_TH","IBIAS_INT","IBIAS_CE_IN","IBIAS_CE_PZ","IBIAS_0T","IBIAS
      _PZ","IBIAS_V0T"};
45     string analogParams[4][7]=      { {"CINT_SUBCH0[0]","CINT_SUBCH1[0]","IOFF_SU
      BCH0[0]","IOFF_SUBCH1[0]","ZERO[0]","POLE[0]","ZIN[0]"}
46                                                                 , {"CINT_SUBCH0[1
      ]","CINT_SUBCH1[1]","IOFF_SUBCH0[1]","IOFF_SUBCH1[1]","ZERO[1]","POLE[1]","ZIN[1]
      "}
47                                                                 , {"CINT_SUBCH0[2
      ]","CINT_SUBCH1[2]","IOFF_SUBCH0[2]","IOFF_SUBCH1[2]","ZERO[2]","POLE[2]","ZIN[2]
      "}
48                                                                 , {"CINT_SUBCH0[3
      ]","CINT_SUBCH1[3]","IOFF_SUBCH0[3]","IOFF_SUBCH1[3]","ZERO[3]","POLE[3]","ZIN[3]
      "}           };
49     string delayLineParams[4][5]= { {"PHASE_ADC[0]","PHASE_TH[0]","PHASE_INT[0]",
      "LOC_SEL[0]","LVDS_OEN[0]"}
50                                                                 ,{"PHASE_ADC[1]",
      "PHASE_TH[1]","PHASE_INT[1]","LOC_SEL[1]","LVDS_OEN[1]"}
51                                                                 ,{"PHASE_ADC[2]",
      "PHASE_TH[2]","PHASE_INT[2]","LOC_SEL[2]","LVDS_OEN[2]"}
52                                                                 ,{"PHASE_ADC[3]",
      "PHASE_TH[3]","PHASE_INT[3]","LOC_SEL[3]","LVDS_OEN[3]"}                };
53 
54     nParams = parseParameterList(configFile, paramName, paramValue);
55 
56     if(nParams != -1)
57     {
58         //At this point we have an array of parameter names (string) and an array
       of values (int).
59         //We obtain the parameter values of the 'mainParams' array by searching o
      n the C++ dictionary.
60         asicParams = fillParams(mainParams,12,paramName,paramValue,nParams);
61         setMainReg(asicParams);
62         PyList_Append(fullConfiguration,asicParams);
63 
64         for(int iCh=0 ; iCh<4 ; iCh++)
65         {
66             asicParams = fillParams(analogParams[iCh],7,paramName,paramValue,nPar
      ams);           //Parameters of the analog channel.
67             setAnalogCh(iCh,asicParams);
68             PyList_Append(fullConfiguration,asicParams);
69             asicParams = fillParams(delayLineParams[iCh],5,paramName,paramValue,n
      Params);        //Parameters of the delay line channel.
70             setDelayLineCh(iCh,asicParams);     
71             PyList_Append(fullConfiguration,asicParams);
72         }
73     }
74     return fullConfiguration;
75 }
\end{DoxyCode}
\hypertarget{classObject_ac5d59299273cee27aacf7de00d2e7034}{
\index{ICECALv3@{ICECALv3}!msg@{msg}}
\index{msg@{msg}!ICECALv3@{ICECALv3}}
\subsubsection[{msg}]{\setlength{\rightskip}{0pt plus 5cm}void Object::msg (std::string {\em mymsg}, \/  std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_ac5d59299273cee27aacf7de00d2e7034}


Definition at line 43 of file Object.h.

References Object::m\_\-log, MsgSvc::msgSvc(), and MsgSvc::NONE.


\begin{DoxyCode}
43 { m_log.msgSvc (MsgSvc::NONE    , mymsg, name ); }
\end{DoxyCode}
\hypertarget{classObject_a58b2d0618c2d08cf2383012611528d97}{
\index{ICECALv3@{ICECALv3}!msg@{msg}}
\index{msg@{msg}!ICECALv3@{ICECALv3}}
\subsubsection[{msg}]{\setlength{\rightskip}{0pt plus 5cm}void Object::msg (std::string {\em mymsg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a58b2d0618c2d08cf2383012611528d97}


Definition at line 35 of file Object.h.

References Object::m\_\-log, Object::m\_\-name, MsgSvc::msgSvc(), and MsgSvc::NONE.

Referenced by export\_\-obj().


\begin{DoxyCode}
35 { m_log.msgSvc (MsgSvc::NONE    , mymsg, m_name ); }
\end{DoxyCode}
\hypertarget{classObject_a3f9d5537ebce0c0f2bf6ae4d92426f3c}{
\index{ICECALv3@{ICECALv3}!msgSvc@{msgSvc}}
\index{msgSvc@{msgSvc}!ICECALv3@{ICECALv3}}
\subsubsection[{msgSvc}]{\setlength{\rightskip}{0pt plus 5cm}void Object::msgSvc (int {\em level}, \/  std::string {\em msg}, \/  std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a3f9d5537ebce0c0f2bf6ae4d92426f3c}


Definition at line 33 of file Object.h.

References Object::m\_\-log, and MsgSvc::msgSvc().

Referenced by Application::banner(), export\_\-obj(), SpecsMezzanine::help(), DCU::readMode(), DCU::setHIR(), DCU::setLIR(), and Hierarchy::tree().


\begin{DoxyCode}
33 { m_log.msgSvc ( (MsgSvc::MsgLevel)(level), msg, name ); }
\end{DoxyCode}
\hypertarget{classObject_a975e888d50bfcbffda2c86368332a5cd}{
\index{ICECALv3@{ICECALv3}!name@{name}}
\index{name@{name}!ICECALv3@{ICECALv3}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string Object::name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a975e888d50bfcbffda2c86368332a5cd}


Definition at line 28 of file Object.h.

References Object::m\_\-name.

Referenced by SpecsMezzanine::addBus(), Hierarchy::addChild(), SpecsSlave::addI2c(), Hierarchy::child(), Hierarchy::childTyped(), Hierarchy::clear(), A3PE::clockDivision(), UsbFTMLInterface::close(), UsbFTInterface::close(), Element::connection(), SpecsSlave::detect(), IOdata::dump(), A3PE::enableStorage(), export\_\-obj(), export\_\-proc(), A3PE::fifoDepth(), A3PE::fifoLatency(), Register::getBit(), SpecsParallelBus::help(), SpecsInterface::help(), NI6008::help(), Computer::help(), UsbSpiBus::help(), UsbI2cBus::help(), RAM::help(), IOobject::help(), UsbMLSpiBus::help(), UsbMLI2cBus::help(), UsbFTMLInterface::help(), SeqPGA::help(), ICPhaser::help(), FePGA::help(), FEB\_\-v1::help(), CU\_\-v1::help(), UsbFTInterface::help(), Proto40MHz\_\-v1::help(), A3PE::help(), Phaser::help(), Croc::help(), MSOxxxx::help(), LSDelayChipV1::help(), help(), SpecsSlave::init(), SpecsMaster::init(), SpecsParallelBus::init(), SpecsInterface::init(), NI6008::init(), Computer::init(), UsbFTMLInterface::init(), UsbFTInterface::init(), Croc::init(), CurrentMeasurement::initialize(), ADCMeasurement::initialize(), EmulateFE::initialize(), StorageFifoAcquisition::initialize(), StorageFifo::initialize(), Acquisition::initialize(), A3PE\_\-BitFlip::initialize(), PhaserRampExec::initialize(), A3PE::latencyAX(), A3PE::lengthAX(), Application::network(), A3PE::nTrigger(), Processus::openRootFile(), Hierarchy::path(), Hierarchy::pathTyped(), A3PE::pipeline(), ICPhaser::read(), Phaser::read(), SpecsSlave::reset(), SpecsMaster::reset(), SpecsParallelBus::reset(), SpecsInterface::reset(), NI6008::reset(), Computer::reset(), UsbSpiBus::reset(), UsbI2cBus::reset(), UsbMLSpiBus::reset(), UsbMLI2cBus::reset(), UsbFTMLInterface::reset(), FEB\_\-v1::reset(), CU\_\-v1::reset(), UsbFTInterface::reset(), Proto40MHz\_\-v1::reset(), A3PE::reset(), Croc::reset(), SpecsSlave::resetInternal(), FEB\_\-v1::resetSpi(), A3PE::setAddFromAXRam(), A3PE::setAddToAXRam(), Register::setBit(), A3PE::setClockDivision(), Application::setConfig(), Element::setConnection(), A3PE::setFifoDepth(), A3PE::setFifoLatency(), A3PE::setLatencyAX(), A3PE::setLengthAX(), A3PE::setNTrigger(), A3PE::setPipeline(), SpecsMaster::setSpeed(), A3PE::setTriggerDelay(), A3PE::setTriggerRate(), SpecsBus::SpecsBus(), SpecsI2c::SpecsI2c(), SpecsParallelBus::SpecsParallelBus(), Server::start(), Processus::startProcessing(), Processus::storage(), Application::terminate(), Hierarchy::tree(), A3PE::triggerDelay(), A3PE::triggerRate(), SpecsParallelBus::update(), SpecsInterface::update(), NI6008::update(), Computer::update(), UsbSpiBus::update(), UsbI2cBus::update(), UsbMLSpiBus::update(), UsbMLI2cBus::update(), UsbFTMLInterface::update(), FEB\_\-v1::update(), CU\_\-v1::update(), UsbFTInterface::update(), Proto40MHz\_\-v1::update(), Croc::update(), UsbFTMLInterface::usbReadU16(), UsbFTInterface::usbReadU16(), UsbFTMLInterface::usbReadU32(), UsbFTInterface::usbReadU32(), UsbFTMLInterface::usbReadU8(), UsbFTInterface::usbReadU8(), UsbFTMLInterface::usbWriteRead(), UsbFTInterface::usbWriteRead(), UsbFTMLInterface::usbWriteU16(), UsbFTInterface::usbWriteU16(), UsbFTMLInterface::usbWriteU32(), UsbFTInterface::usbWriteU32(), UsbFTMLInterface::usbWriteU8(), UsbFTInterface::usbWriteU8(), ICPhaser::write(), Phaser::write(), and Hierarchy::$\sim$Hierarchy().


\begin{DoxyCode}
28 { return m_name; } //< Get Object m_name
\end{DoxyCode}
\hypertarget{classHierarchy_ab16e84de65fd84e14001a6cf941c8be4}{
\index{ICECALv3@{ICECALv3}!numberOfChildren@{numberOfChildren}}
\index{numberOfChildren@{numberOfChildren}!ICECALv3@{ICECALv3}}
\subsubsection[{numberOfChildren}]{\setlength{\rightskip}{0pt plus 5cm}unsigned long Hierarchy::numberOfChildren ()\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_ab16e84de65fd84e14001a6cf941c8be4}


Definition at line 125 of file Hierarchy.cpp.

References Hierarchy::m\_\-children.

Referenced by export\_\-obj().


\begin{DoxyCode}
125                                            {
126   return m_children.size();
127 }
\end{DoxyCode}
\hypertarget{classHierarchy_aee461dc930ce3871636ff87f075b1b83}{
\index{ICECALv3@{ICECALv3}!origin@{origin}}
\index{origin@{origin}!ICECALv3@{ICECALv3}}
\subsubsection[{origin}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Hierarchy}$\ast$ Hierarchy::origin ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classHierarchy_aee461dc930ce3871636ff87f075b1b83}


Definition at line 30 of file Hierarchy.h.

References Hierarchy::m\_\-origin.

Referenced by Hierarchy::child(), export\_\-obj(), and Hierarchy::setParent().


\begin{DoxyCode}
30 { return m_origin; }  //< Get the origin of the tree
\end{DoxyCode}
\hypertarget{classHierarchy_ad550588733bf75ac5c0fcfd7c8fd11a6}{
\index{ICECALv3@{ICECALv3}!parent@{parent}}
\index{parent@{parent}!ICECALv3@{ICECALv3}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Hierarchy} $\ast$ Hierarchy::parent (std::string {\em type})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_ad550588733bf75ac5c0fcfd7c8fd11a6}


Definition at line 327 of file Hierarchy.cpp.

References Hierarchy::parent(), and Object::type().


\begin{DoxyCode}
327                                             {
328   Hierarchy *parent = this->parent();
329   if ( 0 != parent){
330     if (parent->type().compare( type )==0) {
331       return parent;
332     }
333     else
334       return parent->parent( type );
335   }
336   else {
337     return (Hierarchy*)NULL;
338   }
339 }
\end{DoxyCode}
\hypertarget{classHierarchy_a1c7bec8257e717f9c1465e06ebf845fc}{
\index{ICECALv3@{ICECALv3}!parent@{parent}}
\index{parent@{parent}!ICECALv3@{ICECALv3}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Hierarchy}$\ast$ Hierarchy::parent ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classHierarchy_a1c7bec8257e717f9c1465e06ebf845fc}


Definition at line 28 of file Hierarchy.h.

References Hierarchy::m\_\-parent.

Referenced by Hierarchy::child(), Hierarchy::childTyped(), export\_\-obj(), UsbSpiBus::init(), UsbI2cBus::init(), IOobject::init(), UsbMLSpiBus::init(), UsbMLI2cBus::init(), Hierarchy::parent(), Hierarchy::path(), Hierarchy::pathTyped(), Element::setConnection(), Hierarchy::setParent(), SpecsInterface::specsMaster(), SpecsInterface::specsMasterDevice(), SpecsInterface::specsSlave(), SpecsInterface::specsSlaveDevice(), and Hierarchy::$\sim$Hierarchy().


\begin{DoxyCode}
28 { return m_parent; }  //< Get Hierarchy Parent
\end{DoxyCode}
\hypertarget{classICECALv3_a313e8166af1ce26b4026f883ad900fb9}{
\index{ICECALv3@{ICECALv3}!parseParameterList@{parseParameterList}}
\index{parseParameterList@{parseParameterList}!ICECALv3@{ICECALv3}}
\subsubsection[{parseParameterList}]{\setlength{\rightskip}{0pt plus 5cm}int ICECALv3::parseParameterList (string {\em configFile}, \/  string {\em paramName}\mbox{[}64\mbox{]}, \/  int {\em paramValue}\mbox{[}64\mbox{]})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_a313e8166af1ce26b4026f883ad900fb9}


Definition at line 77 of file ICECALv3.cpp.

References Object::error().

Referenced by loadConfig().


\begin{DoxyCode}
78 {
79     int iParams = 0, eqPos;
80     string line;    
81 
82     std::ifstream fd(configFile.c_str());
83     if(!fd)                                 //File NOT OK.
84     {
85         error(configFile+" could not be opened.","ICECALv3::loadConfig");
86         return -1;
87   }
88     else                                        //File OK.
89     {
90         while(!fd.eof())                                    
91         {
92             getline(fd,line);
93             eqPos = line.find("=");
94             if((eqPos != string::npos) && (line[0] != '#'))     //If current line
       contains "=" and DO NOT start with "#", is a good parameter.
95             {
96                 paramName[iParams]  = line.substr(0,eqPos);                                                         /
      /We store the parameter name
97                 paramValue[iParams] = atoi(line.substr(eqPos+1,string::npos).c_st
      r());   //and the parameter value.
98                 iParams++;
99             }
100         }
101         return iParams;
102     }
103 }
\end{DoxyCode}
\hypertarget{classHierarchy_aa7990fa7caf132d83e361ce033c6c65a}{
\index{ICECALv3@{ICECALv3}!path@{path}}
\index{path@{path}!ICECALv3@{ICECALv3}}
\subsubsection[{path}]{\setlength{\rightskip}{0pt plus 5cm}std::string Hierarchy::path (std::string {\em str} = {\ttfamily std::string(\char`\"{}\char`\"{})})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_aa7990fa7caf132d83e361ce033c6c65a}


Definition at line 344 of file Hierarchy.cpp.

References Hierarchy::m\_\-parent, Object::name(), Hierarchy::parent(), and Hierarchy::path().

Referenced by export\_\-obj(), Hierarchy::path(), UsbFTMLInterface::usbReadU16(), UsbFTMLInterface::usbReadU32(), UsbFTMLInterface::usbReadU8(), UsbFTMLInterface::usbWriteRead(), UsbFTMLInterface::usbWriteU16(), UsbFTMLInterface::usbWriteU32(), and UsbFTMLInterface::usbWriteU8().


\begin{DoxyCode}
344                                       {
345   str="/"+name()+str;
346   Hierarchy *m_parent=parent();
347   if (0!=m_parent){
348     return m_parent->path(str);
349   }
350   return str;
351 }
\end{DoxyCode}
\hypertarget{classHierarchy_a1efd56cd164d328d2002e53a10a19b8c}{
\index{ICECALv3@{ICECALv3}!pathTyped@{pathTyped}}
\index{pathTyped@{pathTyped}!ICECALv3@{ICECALv3}}
\subsubsection[{pathTyped}]{\setlength{\rightskip}{0pt plus 5cm}std::string Hierarchy::pathTyped (std::string {\em str} = {\ttfamily std::string(\char`\"{}\char`\"{})})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_a1efd56cd164d328d2002e53a10a19b8c}


Definition at line 356 of file Hierarchy.cpp.

References Hierarchy::m\_\-parent, Object::name(), Hierarchy::parent(), Hierarchy::pathTyped(), and Object::type().

Referenced by export\_\-obj(), and Hierarchy::pathTyped().


\begin{DoxyCode}
356                                            {
357   Hierarchy *m_parent=parent();
358   if (0!=m_parent){
359     str="/"+name()+"["+type()+"]"+str;
360     return m_parent->pathTyped(str);
361   }
362   return str;
363 }
\end{DoxyCode}
\hypertarget{classElement_a82119ed37dff76508a2746a853ec35ba}{
\index{ICECALv3@{ICECALv3}!recursiveInitCommunications@{recursiveInitCommunications}}
\index{recursiveInitCommunications@{recursiveInitCommunications}!ICECALv3@{ICECALv3}}
\subsubsection[{recursiveInitCommunications}]{\setlength{\rightskip}{0pt plus 5cm}void Element::recursiveInitCommunications ()\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classElement_a82119ed37dff76508a2746a853ec35ba}
Triggers a recursive call to initCommunications() for the full hierarchy

\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}


Reimplemented in \hyperlink{classSpecsSlave_a347b94c2ba660ccde6927fe72590a1bc}{SpecsSlave}.

Definition at line 44 of file Element.cpp.

References Hierarchy::children().

Referenced by export\_\-obj().


\begin{DoxyCode}
44                                          {
45   std::vector<Hierarchy*> list = children();
46   std::vector<Hierarchy*>::const_iterator iter;
47   for (iter=list.begin();iter!=list.end();iter++){
48     dynamic_cast<Element*>((*iter))->recursiveInitCommunications();
49   }
50 }
\end{DoxyCode}
\hypertarget{classElement_a3c0abcb36f8906688bb7e32608df7086}{
\index{ICECALv3@{ICECALv3}!recursiveInitElement@{recursiveInitElement}}
\index{recursiveInitElement@{recursiveInitElement}!ICECALv3@{ICECALv3}}
\subsubsection[{recursiveInitElement}]{\setlength{\rightskip}{0pt plus 5cm}void Element::recursiveInitElement ()\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classElement_a3c0abcb36f8906688bb7e32608df7086}
Triggers a recursive call to \hyperlink{classElement_af42754b5cabc198869222725218d695c}{init()} for the full hierarchy

\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}


Definition at line 32 of file Element.cpp.

References Hierarchy::children(), and Element::init().

Referenced by export\_\-obj().


\begin{DoxyCode}
32                                   {
33   init();
34   std::vector<Hierarchy*> list = children();
35   std::vector<Hierarchy*>::iterator iter;
36   for (iter=list.begin() ; iter!=list.end() ; ++iter){
37     dynamic_cast<Element*>((*iter))->recursiveInitElement();
38   }
39 }
\end{DoxyCode}
\hypertarget{classAttrib_a7d4ef7e32d93cb287792b87b857e79f3}{
\index{ICECALv3@{ICECALv3}!remove@{remove}}
\index{remove@{remove}!ICECALv3@{ICECALv3}}
\subsubsection[{remove}]{\setlength{\rightskip}{0pt plus 5cm}void Attrib::remove (int {\em attribut})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classAttrib_a7d4ef7e32d93cb287792b87b857e79f3}
Remove an attribut 

Definition at line 86 of file Attrib.h.

References Attrib::add(), Attrib::m\_\-attributs, and Attrib::UNDEFINED.

Referenced by export\_\-obj().


\begin{DoxyCode}
86                                {
87     std::vector<int>::iterator iter , toremove ;
88     for ( iter  = m_attributs.begin() ;
89           iter != m_attributs.end()   ;
90           ++iter ) {
91       if ( attribut == (*iter) ) {
92         toremove = iter;
93       }
94     }
95     m_attributs.erase (toremove);
96     if(0==m_attributs.size()) add(Attrib::UNDEFINED);
97   }
\end{DoxyCode}
\hypertarget{classICECALv3_a33afc7c8e0f399336152abd03cbe8d1b}{
\index{ICECALv3@{ICECALv3}!reset@{reset}}
\index{reset@{reset}!ICECALv3@{ICECALv3}}
\subsubsection[{reset}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::reset ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classICECALv3_a33afc7c8e0f399336152abd03cbe8d1b}
Resets the \hyperlink{classElement}{Element} so that is is in a standard and safe situation. Different from \hyperlink{classElement_af42754b5cabc198869222725218d695c}{Element::init} which configure the \hyperlink{classElement}{Element}. \hyperlink{classElement_a69efffa22f06909d768149715565cb56}{Element::reset()} is more an Emergency pull. It is often/usually called by the recursiveInitElement method at the start of the program. 

Implements \hyperlink{classElement_a69efffa22f06909d768149715565cb56}{Element}.

Definition at line 655 of file ICECALv3.cpp.


\begin{DoxyCode}
655                     {
656 
657 }
\end{DoxyCode}
\hypertarget{classICECALv3_a1b9ca0e09d45634a70da6f19a7257314}{
\index{ICECALv3@{ICECALv3}!resetPumps@{resetPumps}}
\index{resetPumps@{resetPumps}!ICECALv3@{ICECALv3}}
\subsubsection[{resetPumps}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::resetPumps ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classICECALv3_a1b9ca0e09d45634a70da6f19a7257314}


Definition at line 69 of file ICECALv3.h.

References SC\_\-SOFT\_\-RST, and spiWrite().


\begin{DoxyCode}
69 {                                       spiWrite(SC_SOFT_RST,0);                                    }
      ;
\end{DoxyCode}
\hypertarget{classICECALv3_aaf38119f47401a85022ae1b0d05675bd}{
\index{ICECALv3@{ICECALv3}!setAddress@{setAddress}}
\index{setAddress@{setAddress}!ICECALv3@{ICECALv3}}
\subsubsection[{setAddress}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::setAddress ({\bf U8} {\em address})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classICECALv3_aaf38119f47401a85022ae1b0d05675bd}


Definition at line 65 of file ICECALv3.h.

References confReg, and IOobject::setAddress().

Referenced by BOOST\_\-PYTHON\_\-MODULE().


\begin{DoxyCode}
65 {   confReg->setAddress(address);   }
\end{DoxyCode}
\hypertarget{classICECALv3_a9578e4d13c250d8bc417f68c79d6a21d}{
\index{ICECALv3@{ICECALv3}!setAnalogCh@{setAnalogCh}}
\index{setAnalogCh@{setAnalogCh}!ICECALv3@{ICECALv3}}
\subsubsection[{setAnalogCh}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StatusCode} ICECALv3::setAnalogCh (int {\em ch}, \/  PyObject $\ast$ {\em icecalChParams})}}
\label{classICECALv3_a9578e4d13c250d8bc417f68c79d6a21d}


Definition at line 361 of file ICECALv3.cpp.

References err, Object::error(), StatusCode::FAILURE, icecalLSBAddrCh, icecalMSBAddrCh, itohs(), spiWriteSafe(), and StatusCode::SUCCESS.

Referenced by BOOST\_\-PYTHON\_\-MODULE(), and loadConfig().


\begin{DoxyCode}
362 {                            
363     U16 hTx, lTx;
364     int cIntMsb, cIntLsb0, cIntLsb1, cIntSubCh0, cIntSubCh1, iOffMsb, iOffLsb0, i
      OffLsb1;
365     int iOffSubCh0, iOffSubCh1, zero, pole, zIn;
366 
367     U8 spiLsbAddr = icecalLSBAddrCh[ch];            //The SPI address of the 16 L
      SBs.
368     U8 spiMsbAddr = icecalMSBAddrCh[ch];            //The SPI address of the 16 M
      SBs.
369 
370     cIntSubCh0 = PyInt_AsLong(PyList_GetItem(icecalChParams,0));
371     cIntSubCh1 = PyInt_AsLong(PyList_GetItem(icecalChParams,1));
372     iOffSubCh0 = PyInt_AsLong(PyList_GetItem(icecalChParams,2));
373     iOffSubCh1 = PyInt_AsLong(PyList_GetItem(icecalChParams,3));
374     zero             = PyInt_AsLong(PyList_GetItem(icecalChParams,4));
375     pole             = PyInt_AsLong(PyList_GetItem(icecalChParams,5));
376     zIn              = PyInt_AsLong(PyList_GetItem(icecalChParams,6));
377 
378     //Integretor Capacitor and Offset current configuration registers share the M
      SBs between subchannels.
379     //Therefore, these MSBs must be equal. Otherwise registers won't be properly 
      configured. 
380     if(((cIntSubCh0 & 0x18) == (cIntSubCh1 & 0x18)) && ((iOffSubCh0 & 0x3C) == (i
      OffSubCh1 & 0x3C)))
381     {
382         //Integretor capacitor: 2 + 3 bits.
383         cIntMsb  = (cIntSubCh0 >> 3) & 0x3;
384         cIntLsb0 =  cIntSubCh0 & 0x7;
385         cIntLsb1 =  cIntSubCh1 & 0x7;
386         //Offset current: 4 + 2 bits.
387         iOffMsb  = (iOffSubCh0 >> 2) & 0xF;
388         iOffLsb0 =  iOffSubCh0 & 0x3;
389         iOffLsb1 =  iOffSubCh1 & 0x3;
390 
391         hTx =  ((cIntMsb & 0x3) << 14) | ((cIntLsb0 & 0x7) << 11) | ((cIntLsb1 & 
      0x7) << 8) | 
392                      ((iOffMsb & 0xF) << 4)  | ((iOffLsb0 & 0x3) << 2)  | ((iOffL
      sb1 & 0x3));
393         lTx =    ((zero & 0x1F) << 11)   | ((pole & 0x3F) << 5)     | (zIn & 0x1F
      );
394 
395                             err = spiWriteSafe(spiMsbAddr,hTx); 
396         if(!err)    err = spiWriteSafe(spiLsbAddr,lTx);
397 
398         if(err) return StatusCode::FAILURE;
399         else        return StatusCode::SUCCESS;
400     }
401     else 
402     {
403         if((cIntSubCh0 & 0x18) != (cIntSubCh1 & 0x18)) error("Integrator Cap MSB 
      sub-channel mismatch. MSB<0> = "+itohs(cIntSubCh0)+", MSB<1> = "+itohs(cIntSubCh1
      )+".","ICECALv3::setAnalogCh");
404         if((iOffSubCh0 & 0x3C) != (iOffSubCh1 & 0x3C)) error("Offset Current MSB 
      sub-channel mismatch. MSB<0> = "+itohs(iOffSubCh0)+", MSB<1> = "+itohs(iOffSubCh1
      )+".","ICECALv3::setAnalogCh");
405         return StatusCode::FAILURE;
406     }
407 }
\end{DoxyCode}
\hypertarget{classElement_ab476b4b1df5954141ceb14f072433b89}{
\index{ICECALv3@{ICECALv3}!setConnection@{setConnection}}
\index{setConnection@{setConnection}!ICECALv3@{ICECALv3}}
\subsubsection[{setConnection}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StatusCode} Element::setConnection ({\bf Hierarchy} $\ast$ {\em connection})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classElement_ab476b4b1df5954141ceb14f072433b89}
Define IO interface 

Definition at line 55 of file Element.cpp.

References Object::debug(), StatusCode::FAILURE, Object::fatal(), Attrib::INTERFACE, Attrib::is(), Element::m\_\-connection, Object::name(), Hierarchy::parent(), StatusCode::SUCCESS, and Object::type().

Referenced by export\_\-obj(), UsbSpiBus::init(), UsbI2cBus::init(), IOobject::init(), UsbMLSpiBus::init(), and UsbMLI2cBus::init().


\begin{DoxyCode}
55                                                       {
56   if (0==connection){
57     fatal("Try to define a connection with a null pointer.",
58         "Element::setConnection");
59     return StatusCode::FAILURE;
60   }
61   if (connection->is(Attrib::INTERFACE)){
62     m_connection=dynamic_cast<Hierarchy*>(connection);
63     return StatusCode::SUCCESS;
64   }
65   else {
66     debug(connection->name()+
67         " is not a Attrib::INTERFACE hardware. Connection refused.",
68         "Element::setConnection");
69     if (0!=connection->parent()){
70       return setConnection(connection->parent());
71     }
72     else{
73       fatal("Could not find a connection for element "+
74           name()+"["+type()+"].","element::setConnection");
75       return StatusCode::FAILURE;
76     }
77   }
78 }
\end{DoxyCode}
\hypertarget{classICECALv3_a14a7a29c9a3412c062f053cc616b860a}{
\index{ICECALv3@{ICECALv3}!setDelayLineCh@{setDelayLineCh}}
\index{setDelayLineCh@{setDelayLineCh}!ICECALv3@{ICECALv3}}
\subsubsection[{setDelayLineCh}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StatusCode} ICECALv3::setDelayLineCh (int {\em ch}, \/  PyObject $\ast$ {\em dllParams})}}
\label{classICECALv3_a14a7a29c9a3412c062f053cc616b860a}


Definition at line 281 of file ICECALv3.cpp.

References delayLineAddrCh, err, StatusCode::FAILURE, spiWriteSafe(), and StatusCode::SUCCESS.

Referenced by BOOST\_\-PYTHON\_\-MODULE(), and loadConfig().


\begin{DoxyCode}
282 {                            
283     U16 txData;
284     int phaseADC, phaseTH, phaseINT, locSel, lvdsOEn;
285 
286     U8 spiAddr = delayLineAddrCh[ch];           //The SPI address of this delay l
      ine channel.
287 
288     //Converts the elements of the PyList to integers.
289     phaseADC = PyInt_AsLong(PyList_GetItem(dllParams,0));
290     phaseTH  = PyInt_AsLong(PyList_GetItem(dllParams,1));
291     phaseINT = PyInt_AsLong(PyList_GetItem(dllParams,2));
292     locSel   = PyInt_AsLong(PyList_GetItem(dllParams,3));
293     lvdsOEn  = PyInt_AsLong(PyList_GetItem(dllParams,4));
294 
295     //txData contains the 16 bits corresponding to the delay line channel.
296     txData =  ((phaseADC & 0x1F) << 11) | ((phaseTH & 0x1F) << 6) | ((phaseINT & 
      0x1F) << 3) | ((locSel & 0x03) << 1) | (lvdsOEn & 0x01);
297 
298     //Data is sent and checked. If there is a random write/read error, data is wr
      itten again.
299     err = spiWriteSafe(spiAddr,txData); 
300 
301     if(err) return StatusCode::FAILURE;
302     else        return StatusCode::SUCCESS;
303 }
\end{DoxyCode}
\hypertarget{classObject_a870c5af919958c2136623b2d7816d123}{
\index{ICECALv3@{ICECALv3}!setDllName@{setDllName}}
\index{setDllName@{setDllName}!ICECALv3@{ICECALv3}}
\subsubsection[{setDllName}]{\setlength{\rightskip}{0pt plus 5cm}void Object::setDllName (std::string {\em dllName})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a870c5af919958c2136623b2d7816d123}
Set accessor to member m\_\-dllName 
\begin{DoxyParams}{Parameters}
\item[{\em dllName}]the new value for m\_\-dllName \end{DoxyParams}


Definition at line 66 of file Object.h.

References Object::m\_\-dllName.

Referenced by DLL::createElement(), DLL::createProcessus(), and Object::Object().


\begin{DoxyCode}
66                                       {
67     m_dllName = dllName;
68   }
\end{DoxyCode}
\hypertarget{classObject_a398fe08cba594a0ce6891d59fe4f159f}{
\index{ICECALv3@{ICECALv3}!setId@{setId}}
\index{setId@{setId}!ICECALv3@{ICECALv3}}
\subsubsection[{setId}]{\setlength{\rightskip}{0pt plus 5cm}void Object::setId (unsigned char {\em id})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a398fe08cba594a0ce6891d59fe4f159f}


Definition at line 53 of file Object.h.

References Object::m\_\-id.

Referenced by A3PE::A3PE(), DCU::DCU(), export\_\-obj(), FePGA::FePGA(), ICECALv3(), ICPhaser::ICPhaser(), LSDelayChipV1::LSDelayChipV1(), MSOxxxx::MSOxxxx(), Object::Object(), Phaser::Phaser(), SeqPGA::SeqPGA(), SpecsBus::SpecsBus(), SpecsI2c::SpecsI2c(), SpecsInterface::SpecsInterface(), SpecsMaster::SpecsMaster(), SpecsParallelBus::SpecsParallelBus(), and SpecsSlave::SpecsSlave().


\begin{DoxyCode}
53 { m_id    = id    ; } //< Set Object m_id
\end{DoxyCode}
\hypertarget{classICECALv3_a479f7e17669da4b785af840049d39cb4}{
\index{ICECALv3@{ICECALv3}!setMainReg@{setMainReg}}
\index{setMainReg@{setMainReg}!ICECALv3@{ICECALv3}}
\subsubsection[{setMainReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StatusCode} ICECALv3::setMainReg (PyObject $\ast$ {\em icecalMainParams})}}
\label{classICECALv3_a479f7e17669da4b785af840049d39cb4}


Definition at line 474 of file ICECALv3.cpp.

References err, StatusCode::FAILURE, icecalMainAddr, spiWriteSafe(), and StatusCode::SUCCESS.

Referenced by BOOST\_\-PYTHON\_\-MODULE(), and loadConfig().


\begin{DoxyCode}
475 {                            
476     U16 txD[4];
477 
478     int vCtlOE, bxidSynOE, clkRefreshEn, iBiasOB, iBiasCETH, iBiasTH, iBiasINT;
479     int iBiasCEINT, iBiasCEPZ, iBias0T, iBiasPZ, iBiasV0T;
480     
481     vCtlOE              = !PyInt_AsLong(PyList_GetItem(icecalMainParams,0));    /
      /Active low.
482     bxidSynOE       = !PyInt_AsLong(PyList_GetItem(icecalMainParams,1));    //Act
      ive low.
483     clkRefreshEn    = !PyInt_AsLong(PyList_GetItem(icecalMainParams,2));    //Act
      ive low.
484     iBiasOB         = PyInt_AsLong(PyList_GetItem(icecalMainParams,3));
485     iBiasCETH           = PyInt_AsLong(PyList_GetItem(icecalMainParams,4));
486     iBiasTH             = PyInt_AsLong(PyList_GetItem(icecalMainParams,5));
487     iBiasINT            = PyInt_AsLong(PyList_GetItem(icecalMainParams,6));
488     iBiasCEINT      = PyInt_AsLong(PyList_GetItem(icecalMainParams,7));
489     iBiasCEPZ       = PyInt_AsLong(PyList_GetItem(icecalMainParams,8));
490     iBias0T             = PyInt_AsLong(PyList_GetItem(icecalMainParams,9));
491     iBiasPZ             = PyInt_AsLong(PyList_GetItem(icecalMainParams,10));
492     iBiasV0T        = PyInt_AsLong(PyList_GetItem(icecalMainParams,11));
493 
494     txD[3] = ((vCtlOE & 0x1) << 15)         | ((bxidSynOE & 0x1) << 14) | ((clkRe
      freshEn & 0x1) << 13) | ((iBiasOB & 0x3F) << 6) | (iBiasCETH & 0x3F);
495     txD[2] = ((iBiasTH & 0x3F) << 6)        |  (iBiasINT  & 0x3F); 
496     txD[1] = ((iBiasCEINT & 0x38) << 9) | ((iBiasCEPZ & 0x3F) << 6) |  (iBias0T  
          & 0x3F);
497     txD[0] = ((iBiasCEINT & 0x7) << 12) | ((iBiasPZ   & 0x3F) << 6) |  (iBiasV0T 
          & 0x3F);
498 
499     //Four 16-bit registers are written.
500     err = 0;
501     for(int i=0;i<4;i++) err |= spiWriteSafe(icecalMainAddr[i],txD[i]);
502 
503     if(err) return StatusCode::FAILURE;
504     else        return StatusCode::SUCCESS;
505 }
\end{DoxyCode}
\hypertarget{classObject_ae30fea75683c2d149b6b6d17c09ecd0c}{
\index{ICECALv3@{ICECALv3}!setName@{setName}}
\index{setName@{setName}!ICECALv3@{ICECALv3}}
\subsubsection[{setName}]{\setlength{\rightskip}{0pt plus 5cm}void Object::setName (std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_ae30fea75683c2d149b6b6d17c09ecd0c}


Definition at line 51 of file Object.h.

References Object::m\_\-name.

Referenced by A3PE::A3PE(), A3PE\_\-BitFlip::A3PE\_\-BitFlip(), Acquisition::Acquisition(), ADCMeasurement::ADCMeasurement(), Computer::Computer(), Application::create(), Croc::Croc(), CU\_\-v1::CU\_\-v1(), CurrentMeasurement::CurrentMeasurement(), EmulateFE::EmulateFE(), export\_\-obj(), FEB\_\-v1::FEB\_\-v1(), FePGA::FePGA(), ICECALv3(), ICPhaser::ICPhaser(), Application::initialize(), Interface::Interface(), IOdata::IOdata(), IOobject::IOobject(), LSDelayChipV1::LSDelayChipV1(), FePGA::MakeRAM(), FePGA::MakeRegister(), Application::network(), NI6008::NI6008(), Object::Object(), PhaserRampExec::PhaserRampExec(), Proto40MHz\_\-v1::Proto40MHz\_\-v1(), RAM::RAM(), Register::Register(), RegisterTest::RegisterTest(), SeqPGA::SeqPGA(), SpecsBus::SpecsBus(), SpecsGlue::SpecsGlue(), SpecsI2c::SpecsI2c(), SpecsMaster::SpecsMaster(), SpecsMezzanine::SpecsMezzanine(), SpecsParallelBus::SpecsParallelBus(), StorageFifo::StorageFifo(), StorageFifoAcquisition::StorageFifoAcquisition(), TestI2C::TestI2C(), TestSPI::TestSPI(), TestSuite::TestSuite(), TestUSB::TestUSB(), UsbFTInterface::UsbFTInterface(), UsbFTInterfaceTest::UsbFTInterfaceTest(), UsbFTMLInterface::UsbFTMLInterface(), UsbI2cBus::UsbI2cBus(), UsbMLI2cBus::UsbMLI2cBus(), UsbMLSpiBus::UsbMLSpiBus(), and UsbSpiBus::UsbSpiBus().


\begin{DoxyCode}
51 { m_name  = name  ; } //< Set Object m_name
\end{DoxyCode}
\hypertarget{classICECALv3_aae0b7539c0bba5311aab99e000d1be6d}{
\index{ICECALv3@{ICECALv3}!setNRetries@{setNRetries}}
\index{setNRetries@{setNRetries}!ICECALv3@{ICECALv3}}
\subsubsection[{setNRetries}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::setNRetries (int {\em nRet})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classICECALv3_aae0b7539c0bba5311aab99e000d1be6d}


Definition at line 66 of file ICECALv3.h.

References nRetries.

Referenced by BOOST\_\-PYTHON\_\-MODULE().


\begin{DoxyCode}
66 {   nRetries = nRet;                                }
\end{DoxyCode}
\hypertarget{classHierarchy_a585ad1aeec16077a0e532ab8b4fc557b}{
\index{ICECALv3@{ICECALv3}!setParent@{setParent}}
\index{setParent@{setParent}!ICECALv3@{ICECALv3}}
\subsubsection[{setParent}]{\setlength{\rightskip}{0pt plus 5cm}void Hierarchy::setParent ({\bf Hierarchy} $\ast$ {\em parent})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_a585ad1aeec16077a0e532ab8b4fc557b}


Definition at line 67 of file Hierarchy.cpp.

References Hierarchy::m\_\-origin, Hierarchy::m\_\-parent, Hierarchy::origin(), and Hierarchy::parent().

Referenced by SpecsMezzanine::addBus(), Hierarchy::addChild(), SpecsSlave::addI2c(), Computer::Computer(), Application::create(), export\_\-obj(), and SpecsMezzanine::SpecsMezzanine().


\begin{DoxyCode}
67                                               {
68   m_parent = parent;
69   if ((Hierarchy*)0==parent) return;
70 
71   Hierarchy *curr = this;
72   Hierarchy *prev = parent;
73   while ( prev != 0 ){
74     curr = prev;
75     prev = curr->parent();
76   }
77   if (parent->origin()!=0) m_origin=parent->origin();
78 }
\end{DoxyCode}
\hypertarget{classObject_a89557dbbad5bcaa02652f5d7fa35d20f}{
\index{ICECALv3@{ICECALv3}!setTitle@{setTitle}}
\index{setTitle@{setTitle}!ICECALv3@{ICECALv3}}
\subsubsection[{setTitle}]{\setlength{\rightskip}{0pt plus 5cm}void Object::setTitle (std::string {\em title})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a89557dbbad5bcaa02652f5d7fa35d20f}


Definition at line 54 of file Object.h.

References Object::m\_\-title.

Referenced by A3PE\_\-BitFlip::A3PE\_\-BitFlip(), Acquisition::Acquisition(), ADCMeasurement::ADCMeasurement(), CurrentMeasurement::CurrentMeasurement(), EmulateFE::EmulateFE(), export\_\-obj(), Histo1D::Histo1D(), Histo2D::Histo2D(), Object::Object(), PhaserRampExec::PhaserRampExec(), RegisterTest::RegisterTest(), StorageFifo::StorageFifo(), StorageFifoAcquisition::StorageFifoAcquisition(), TestI2C::TestI2C(), TestSPI::TestSPI(), TestSuite::TestSuite(), TestUSB::TestUSB(), and UsbFTInterfaceTest::UsbFTInterfaceTest().


\begin{DoxyCode}
54 { m_title = title ; } //< Set Object m_title
\end{DoxyCode}
\hypertarget{classObject_aae534cc9d982bcb9b99fd505f2e103a5}{
\index{ICECALv3@{ICECALv3}!setType@{setType}}
\index{setType@{setType}!ICECALv3@{ICECALv3}}
\subsubsection[{setType}]{\setlength{\rightskip}{0pt plus 5cm}void Object::setType (std::string {\em type})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_aae534cc9d982bcb9b99fd505f2e103a5}


Definition at line 52 of file Object.h.

References Object::m\_\-type.

Referenced by A3PE::A3PE(), A3PE\_\-BitFlip::A3PE\_\-BitFlip(), Acquisition::Acquisition(), ADCMeasurement::ADCMeasurement(), Computer::Computer(), Croc::Croc(), CU\_\-v1::CU\_\-v1(), CurrentMeasurement::CurrentMeasurement(), DCU::DCU(), EmulateFE::EmulateFE(), export\_\-obj(), FEB\_\-v1::FEB\_\-v1(), FePGA::FePGA(), ICECALv3(), ICPhaser::ICPhaser(), Application::initialize(), Interface::Interface(), IOdata::IOdata(), IOobject::IOobject(), LSDelayChipV1::LSDelayChipV1(), MSOxxxx::MSOxxxx(), NI6008::NI6008(), Object::Object(), Phaser::Phaser(), PhaserRampExec::PhaserRampExec(), Proto40MHz\_\-v1::Proto40MHz\_\-v1(), RAM::RAM(), Register::Register(), RegisterTest::RegisterTest(), SeqPGA::SeqPGA(), SpecsBus::SpecsBus(), SpecsGlue::SpecsGlue(), SpecsI2c::SpecsI2c(), SpecsMaster::SpecsMaster(), SpecsMezzanine::SpecsMezzanine(), SpecsParallelBus::SpecsParallelBus(), SpecsSlave::SpecsSlave(), StorageFifo::StorageFifo(), StorageFifoAcquisition::StorageFifoAcquisition(), TestI2C::TestI2C(), TestSPI::TestSPI(), TestSuite::TestSuite(), TestUSB::TestUSB(), UsbFTInterface::UsbFTInterface(), UsbFTInterfaceTest::UsbFTInterfaceTest(), UsbFTMLInterface::UsbFTMLInterface(), UsbI2cBus::UsbI2cBus(), UsbMLI2cBus::UsbMLI2cBus(), UsbMLSpiBus::UsbMLSpiBus(), and UsbSpiBus::UsbSpiBus().


\begin{DoxyCode}
52 { m_type  = type  ; } //< Set Object m_type
\end{DoxyCode}
\hypertarget{classICECALv3_acbf1a7a8510d7e02280bacc58badf4f4}{
\index{ICECALv3@{ICECALv3}!spiAddressScan@{spiAddressScan}}
\index{spiAddressScan@{spiAddressScan}!ICECALv3@{ICECALv3}}
\subsubsection[{spiAddressScan}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::spiAddressScan ()}}
\label{classICECALv3_acbf1a7a8510d7e02280bacc58badf4f4}


Definition at line 688 of file ICECALv3.cpp.

References itohs(), itos(), spiRead(), and Object::warning().

Referenced by BOOST\_\-PYTHON\_\-MODULE().


\begin{DoxyCode}
689 {
690     U16 rxData;
691     unsigned int addr, rw, pumpRst, conf, regSel;
692 
693     for(addr=0; addr<256; addr++)
694     {
695         rw      = (addr>>7);
696         pumpRst = (addr>>6) & 0x01;
697         conf    = (addr>>5) & 0x01;
698         regSel  = addr & 0x1F;
699 
700         rxData = spiRead( (U8) addr , 0x00 );
701         warning("R/!W="+itos(rw)+" PUMPrst="+itos(pumpRst)+" !CONF/STAT="+itos(co
      nf)+" REGsel="+itos(regSel)+" ~ SPI(@=0x"+itohs(addr)+") = 0x"+itohs(rxData),"ICE
      CALv3::spiAddressScan");
702     }
703 }
\end{DoxyCode}
\hypertarget{classICECALv3_a8639cf6a44cba85b53128b5e1dc21e15}{
\index{ICECALv3@{ICECALv3}!spiFERTest@{spiFERTest}}
\index{spiFERTest@{spiFERTest}!ICECALv3@{ICECALv3}}
\subsubsection[{spiFERTest}]{\setlength{\rightskip}{0pt plus 5cm}PyObject $\ast$ ICECALv3::spiFERTest (long {\em nTest})}}
\label{classICECALv3_a8639cf6a44cba85b53128b5e1dc21e15}


Definition at line 577 of file ICECALv3.cpp.

References delayLineAddrCh, Object::error(), icecalLSBAddrCh, icecalMainAddr, icecalMSBAddrCh, Object::info(), itohs(), spiRead(), spiWrite(), and Object::warning().

Referenced by BOOST\_\-PYTHON\_\-MODULE().


\begin{DoxyCode}
578 {
579     long iTest, nBadTx=0, nBadRx=0, nFatal=0, nBad, regErrorHistogram[16];
580     int iFrame, iRetry, readOk, writeOk;
581     double fer;
582     U16 writeData = 0x0000;
583     U16 readData, retry;
584     PyObject* ferStatistics         = PyList_New(0); 
585     PyObject* confRegAddresses  = PyList_New(0);
586     PyObject* confRegHistogram  = PyList_New(0);
587 
588     U8  addr;
589     U8  confRegList[16] = {icecalMainAddr[0] , icecalMainAddr[1] , icecalMainAddr
      [2] , icecalMainAddr[3] , delayLineAddrCh[0] , delayLineAddrCh[1] , delayLineAddr
      Ch[2] , delayLineAddrCh[3] ,
590                                                  icecalLSBAddrCh[0], icecalLSBAdd
      rCh[1], icecalLSBAddrCh[2], icecalLSBAddrCh[3], icecalMSBAddrCh[0] , icecalMSBAdd
      rCh[1] , icecalMSBAddrCh[2] , icecalMSBAddrCh[3]};
591 
592     //Error histogram. This will compute the number of error in each register add
      ress.
593     for(int i=0 ; i<16 ; i++) regErrorHistogram[i] = 0;
594 
595     info("Starting SPI FER test...","ICECALv3::spiFERTest");
596 
597     //FER Test is performed N Times
598     for(iTest=0 ; iTest<nTest ; iTest++)
599     {
600         //For each test we check the 16 RW registers of the chip.
601         for(iFrame=0 ; iFrame<16 ; iFrame++)
602         {
603             addr = confRegList[iFrame];
604 
605             //Random data to be sent.
606             writeData = rand() + rand();
607 
608             //Write + Read back.    
609             spiWrite(addr,writeData);
610             readData = spiRead(addr);   
611 
612             //Data mismatch: let's see if it's a read, write or FATAL error;
613             if(writeData != readData)
614             {
615                 //The number of coincidences are counted. This loop will break wh
      en 5 R/W coincidences are found or after 50 retrials.
616                 iRetry = 0;     readOk = 0;         writeOk = 0;
617                 do
618                 {
619                     retry = spiRead(addr);
620                     if(retry == readData )  readOk++;
621                     if(retry == writeData) writeOk++;
622                     iRetry++;
623                 }
624                 while(readOk < 5 && writeOk < 5 && iRetry < 50);
625 
626                 //Number of total errors according to the source.
627                 if          (iRetry >= 50) {    error("Mismatch: the source of th
      e SPI error could not be determined","ICECALv3::spiFER");   nFatal++;   }
628                 else if (readOk >= 5)    {  error("Mismatch: Write error @SPI = 0
      x"+itohs(addr)+". W = 0x"+itohs(writeData)+", R = 0x"+itohs(readData)+".","ICECAL
      v3::spiFER");   nBadTx++;   }
629                 else                                     {  error("Mismatch: Read
       error @SPI = 0x"+itohs(addr)+".  W = 0x"+itohs(writeData)+", R = 0x"+itohs(readD
      ata)+".","ICECALv3::spiFER");       nBadRx++;   }
630 
631                 //Number of total errors according to the number of SPI register.
      
632                 regErrorHistogram[iFrame]++;
633             }
634         }
635     }
636     nBad = nFatal + nBadTx + nBadRx;                            //Global number o
      f errors.
637     fer = (double)nBad / ((double)nTest * 16.0);    //Frame Rate Error.
638 
639     for(iFrame=0 ; iFrame<16 ; iFrame++) PyList_Append(confRegAddresses, PyInt_Fr
      omLong(confRegList[iFrame]));               //A list with the SPI @s.
640     for(iFrame=0 ; iFrame<16 ; iFrame++) PyList_Append(confRegHistogram, PyInt_Fr
      omLong(regErrorHistogram[iFrame])); //The number of errors in this SPI @s.
641 
642     //FER statistics list:
643     PyList_Append(ferStatistics, PyInt_FromLong(nBad));         //# Bad frames (g
      lobal).
644     PyList_Append(ferStatistics, PyFloat_FromDouble(fer));  //Global FER (0 ~ 1).
      
645     PyList_Append(ferStatistics, PyInt_FromLong(nFatal));       //# Fatal frames.
      
646     PyList_Append(ferStatistics, PyInt_FromLong(nBadTx));       //# Bad TX frames
      .
647     PyList_Append(ferStatistics, PyInt_FromLong(nBadRx));       //# Bad RX frames
      .
648     PyList_Append(ferStatistics, confRegAddresses);                 //SPI @ list.
      
649     PyList_Append(ferStatistics, confRegHistogram);                 //SPI error c
      ounters list.
650 
651     warning("SPI BER test finished!!!");
652     return ferStatistics;
653 }
\end{DoxyCode}
\hypertarget{classICECALv3_aced41ce20a0853d6248b8df88412e57a}{
\index{ICECALv3@{ICECALv3}!spiRead@{spiRead}}
\index{spiRead@{spiRead}!ICECALv3@{ICECALv3}}
\subsubsection[{spiRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf U16} ICECALv3::spiRead ({\bf U8} {\em confRegAddr}, \/  {\bf U8} {\em offsetAddr} = {\ttfamily 128})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_aced41ce20a0853d6248b8df88412e57a}


Definition at line 537 of file ICECALv3.cpp.

References confReg, IOdata::dataU8(), Object::debug(), err, IOobject::io(), StatusCode::isFailure(), itohs(), IOobject::read(), and Object::warning().

Referenced by bxidResynchStatus(), getAnalogCh(), getDelayLineCh(), getMainReg(), spiAddressScan(), spiFERTest(), spiWriteSafe(), and version().


\begin{DoxyCode}
538 {
539     U16 rxData;
540 
541     U8* buffer = confReg->io()->dataU8();
542     buffer[2]  = confRegAddr + offsetAddr;                          //+128 = read
          
543 
544     if (confReg->read().isFailure()) 
545     {
546         warning("ICECALv3 read (@"+itohs(confRegAddr)+") error.","ICECALv3::spiRe
      ad");
547         err = true;
548         return 0;
549     }
550     else
551     {
552         err = false;
553         rxData = ((U16)buffer[1] * 256) + (U16)buffer[0];
554         debug("Register (@"+ itohs(confRegAddr) + ") = 0x" + itohs(rxData),"ICECA
      Lv3::spiRead");
555         return rxData;
556     }
557 
558 }
\end{DoxyCode}
\hypertarget{classICECALv3_aef00f02801dea4bda2093c930501dcdd}{
\index{ICECALv3@{ICECALv3}!spiWrite@{spiWrite}}
\index{spiWrite@{spiWrite}!ICECALv3@{ICECALv3}}
\subsubsection[{spiWrite}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::spiWrite ({\bf U8} {\em confRegAddr}, \/  {\bf U16} {\em confRegData})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_aef00f02801dea4bda2093c930501dcdd}


Definition at line 561 of file ICECALv3.cpp.

References confReg, IOdata::dataU8(), Object::debug(), err, IOobject::io(), StatusCode::isFailure(), itohs(), Object::warning(), and IOobject::write().

Referenced by bypassMisoMosi(), resetPumps(), spiFERTest(), and spiWriteSafe().


\begin{DoxyCode}
562 {
563     U8* buffer = confReg->io()->dataU8();
564     buffer[2] = confRegAddr;                                //Frame = buffer<2>, 
      buffer<1>, buffer<0>
565     buffer[1] = (confRegData >> 8) & 0xFF;
566     buffer[0] =  confRegData       & 0xFF;
567 
568     err = confReg->write().isFailure();
569 
570     if(err)     warning("ICECALv3 write error.","ICECALv3::spiWrite");
571     else      debug("ICECALv3 write (@"+ itohs(confRegAddr) + ") = 0x" + itohs(
      confRegData),"ICECALv3::spiWrite");
572 }
\end{DoxyCode}
\hypertarget{classICECALv3_aa0b8358ea0be8e47a8aded5e1551787f}{
\index{ICECALv3@{ICECALv3}!spiWriteSafe@{spiWriteSafe}}
\index{spiWriteSafe@{spiWriteSafe}!ICECALv3@{ICECALv3}}
\subsubsection[{spiWriteSafe}]{\setlength{\rightskip}{0pt plus 5cm}bool ICECALv3::spiWriteSafe ({\bf U8} {\em confRegAddr}, \/  {\bf U16} {\em confRegData})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_aa0b8358ea0be8e47a8aded5e1551787f}


Definition at line 513 of file ICECALv3.cpp.

References Object::error(), itohs(), nRetries, spiRead(), spiWrite(), and Object::warning().

Referenced by setAnalogCh(), setDelayLineCh(), and setMainReg().


\begin{DoxyCode}
514 {
515     U16 rxRegData;
516     bool ok = true;
517     int iteration = 0;
518 
519     do{
520         //Data is sent and read back...
521         spiWrite(confRegAddr,confRegData);  
522         rxRegData = spiRead(confRegAddr);
523 
524         //Exit conditions are computed.
525         ok = (rxRegData == confRegData);
526         iteration++;
527     
528         if(!ok) warning("Mismatch ("+itohs(iteration)+") in @SPI = 0x"+itohs(conf
      RegAddr)+". Read: 0x"+itohs(rxRegData)+". Expected: 0x"+itohs(confRegAddr)+".","I
      CECALv3::spiWriteSafe"); 
529 
530     }while(!ok && iteration<= nRetries);
531 
532     if(!ok) error("Too many errors ("+itohs(iteration)+"). Check electronics!","I
      CECALv3::spiWriteSafe");
533     return !ok;
534 }
\end{DoxyCode}
\hypertarget{classObject_a73a0f1a41828fdd8303dd662446fb6c3}{
\index{ICECALv3@{ICECALv3}!title@{title}}
\index{title@{title}!ICECALv3@{ICECALv3}}
\subsubsection[{title}]{\setlength{\rightskip}{0pt plus 5cm}std::string Object::title ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a73a0f1a41828fdd8303dd662446fb6c3}


Definition at line 31 of file Object.h.

References Object::m\_\-title.

Referenced by export\_\-obj(), export\_\-proc(), CurrentMeasurement::initialize(), ADCMeasurement::initialize(), StorageFifoAcquisition::initialize(), Acquisition::initialize(), and Application::terminate().


\begin{DoxyCode}
31 { return m_title;      } // < Get Object m_title
\end{DoxyCode}
\hypertarget{classHierarchy_a594c294c5f60c230e106d522ed008212}{
\index{ICECALv3@{ICECALv3}!tree@{tree}}
\index{tree@{tree}!ICECALv3@{ICECALv3}}
\subsubsection[{tree}]{\setlength{\rightskip}{0pt plus 5cm}void Hierarchy::tree ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classHierarchy_a594c294c5f60c230e106d522ed008212}


Definition at line 46 of file Hierarchy.h.

References Hierarchy::tree().

Referenced by export\_\-obj(), and Hierarchy::tree().


\begin{DoxyCode}
46 { tree(""); };                     // output tree of Hierarchy from object
\end{DoxyCode}
\hypertarget{classHierarchy_a76e914b9a677a22a82deb74d892bf261}{
\index{ICECALv3@{ICECALv3}!tree@{tree}}
\index{tree@{tree}!ICECALv3@{ICECALv3}}
\subsubsection[{tree}]{\setlength{\rightskip}{0pt plus 5cm}void Hierarchy::tree (std::string {\em indent} = {\ttfamily std::string(\char`\"{}\char`\"{})})\hspace{0.3cm}{\ttfamily  \mbox{[}inherited\mbox{]}}}}
\label{classHierarchy_a76e914b9a677a22a82deb74d892bf261}


Definition at line 310 of file Hierarchy.cpp.

References Hierarchy::children(), Object::info(), Object::msgSvc(), Object::name(), MsgSvc::NONE, and Object::type().


\begin{DoxyCode}
310                                     {
311   std::string line=indent+" -> "+name()+"["+type()+"] ";
312   if (std::string("")==indent){
313     info("Hierarchy for Object "+name()+"["+type()+"]","Hierarchy::tree");
314   }
315   msgSvc(MsgSvc::NONE,line,"");
316   std::vector<Hierarchy*> list = children();
317   std::vector<Hierarchy*>::iterator iter;
318   for (iter=list.begin() ; iter!=list.end() ; ++iter){
319     std::string tab="  ";
320     (*iter)->tree(indent+tab);
321   }
322 }
\end{DoxyCode}
\hypertarget{classObject_a84f99f70f144a83e1582d1d0f84e4e62}{
\index{ICECALv3@{ICECALv3}!type@{type}}
\index{type@{type}!ICECALv3@{ICECALv3}}
\subsubsection[{type}]{\setlength{\rightskip}{0pt plus 5cm}std::string Object::type ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a84f99f70f144a83e1582d1d0f84e4e62}


Definition at line 29 of file Object.h.

References Object::m\_\-type.

Referenced by DLLMgr::destroy(), DLL::destroy(), IOdata::dump(), export\_\-obj(), UsbSpiBus::init(), UsbI2cBus::init(), UsbMLSpiBus::init(), UsbMLI2cBus::init(), EmulateFE::initialize(), StorageFifoAcquisition::initialize(), StorageFifo::initialize(), Acquisition::initialize(), A3PE\_\-BitFlip::initialize(), PhaserRampExec::initialize(), ProcDataBase::list(), Hierarchy::parent(), Hierarchy::pathTyped(), DLL::print(), ProcDataBase::procList(), Application::setConfig(), Element::setConnection(), and Hierarchy::tree().


\begin{DoxyCode}
29 { return m_type;       } //< Get Object m_type
\end{DoxyCode}
\hypertarget{classICECALv3_ab2a00809e9a4f2ab83ef041a886ca637}{
\index{ICECALv3@{ICECALv3}!update@{update}}
\index{update@{update}!ICECALv3@{ICECALv3}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}void ICECALv3::update ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classICECALv3_ab2a00809e9a4f2ab83ef041a886ca637}
Update the \hyperlink{classElement}{Element} configuration from the actual hardware 

Implements \hyperlink{classElement_a4e6c83efae95616ebddd03c793a26661}{Element}.

Definition at line 127 of file ICECALv3.h.


\begin{DoxyCode}
127                  {
128     
129   };
\end{DoxyCode}
\hypertarget{classObject_a2d4120195317e2a3c6532e8bb9f3da68}{
\index{ICECALv3@{ICECALv3}!verbose@{verbose}}
\index{verbose@{verbose}!ICECALv3@{ICECALv3}}
\subsubsection[{verbose}]{\setlength{\rightskip}{0pt plus 5cm}void Object::verbose (std::string {\em mymsg}, \/  std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a2d4120195317e2a3c6532e8bb9f3da68}


Definition at line 44 of file Object.h.

References Object::m\_\-log, MsgSvc::msgSvc(), and MsgSvc::VERBOSE.


\begin{DoxyCode}
44 { m_log.msgSvc (MsgSvc::VERBOSE , mymsg, name ); }
\end{DoxyCode}
\hypertarget{classObject_a83d2db2df682907ea1115ad721c1c4a1}{
\index{ICECALv3@{ICECALv3}!verbose@{verbose}}
\index{verbose@{verbose}!ICECALv3@{ICECALv3}}
\subsubsection[{verbose}]{\setlength{\rightskip}{0pt plus 5cm}void Object::verbose (std::string {\em mymsg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a83d2db2df682907ea1115ad721c1c4a1}


Definition at line 36 of file Object.h.

References Object::m\_\-log, Object::m\_\-name, MsgSvc::msgSvc(), and MsgSvc::VERBOSE.

Referenced by DCU::acquire(), export\_\-obj(), DCU::init(), Application::prepare(), UsbFTMLInterface::read(), UsbFTInterface::read(), DCU::readMode(), DCU::reset(), DCU::setHIR(), DCU::setLIR(), SpecsInterface::specsReadI2c(), SpecsInterface::specsReadParallel(), SpecsInterface::specsReadRegister(), SpecsInterface::specsWriteI2c(), SpecsInterface::specsWriteParallel(), SpecsInterface::specsWriteRegister(), UsbFTMLInterface::usbRead(), UsbFTInterface::usbRead(), UsbFTMLInterface::usbReadU16(), UsbFTInterface::usbReadU16(), UsbFTMLInterface::usbReadU32(), UsbFTInterface::usbReadU32(), UsbFTMLInterface::usbReadU8(), UsbFTInterface::usbReadU8(), UsbFTMLInterface::usbWrite(), UsbFTInterface::usbWrite(), UsbFTMLInterface::usbWriteRead(), UsbFTInterface::usbWriteRead(), UsbFTMLInterface::usbWriteU16(), UsbFTInterface::usbWriteU16(), UsbFTMLInterface::usbWriteU32(), UsbFTInterface::usbWriteU32(), UsbFTMLInterface::usbWriteU8(), UsbFTInterface::usbWriteU8(), wait(), UsbFTMLInterface::write(), and UsbFTInterface::write().


\begin{DoxyCode}
36 { m_log.msgSvc (MsgSvc::VERBOSE , mymsg, m_name ); }
\end{DoxyCode}
\hypertarget{classICECALv3_a7f3f8012d2e5c45f8e43819befa3f915}{
\index{ICECALv3@{ICECALv3}!version@{version}}
\index{version@{version}!ICECALv3@{ICECALv3}}
\subsubsection[{version}]{\setlength{\rightskip}{0pt plus 5cm}double ICECALv3::version ()}}
\label{classICECALv3_a7f3f8012d2e5c45f8e43819befa3f915}


Definition at line 660 of file ICECALv3.cpp.

References ftos(), ICECAL\_\-VERSION\_\-ADDR, Object::info(), itos(), and spiRead().

Referenced by BOOST\_\-PYTHON\_\-MODULE().


\begin{DoxyCode}
661 {
662     U16 rxversion;
663     double major,minor,version;
664     string version_str;
665 
666     rxversion = spiRead(ICECAL_VERSION_ADDR, 0x00 );
667 
668     major = (double)((rxversion>>12) & 0x0F); 
669     minor = (double)((rxversion >>8) & 0x0F);
670     version_str = itos(major) + "." + itos(minor);
671     version = atof( version_str.c_str() );
672 
673     info("ICECAL Version: " + ftos(version),"ICECALv3::version");
674     return version;
675 }
\end{DoxyCode}
\hypertarget{classObject_a11f101db4dd73d9391b0231818881d86}{
\index{ICECALv3@{ICECALv3}!warning@{warning}}
\index{warning@{warning}!ICECALv3@{ICECALv3}}
\subsubsection[{warning}]{\setlength{\rightskip}{0pt plus 5cm}void Object::warning (std::string {\em mymsg}, \/  std::string {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a11f101db4dd73d9391b0231818881d86}


Definition at line 47 of file Object.h.

References Object::m\_\-log, MsgSvc::msgSvc(), and MsgSvc::WARNING.


\begin{DoxyCode}
47 { m_log.msgSvc (MsgSvc::WARNING , mymsg, name ); }
\end{DoxyCode}
\hypertarget{classObject_a65cd4fda577711660821fd2cd5a3b4c9}{
\index{ICECALv3@{ICECALv3}!warning@{warning}}
\index{warning@{warning}!ICECALv3@{ICECALv3}}
\subsubsection[{warning}]{\setlength{\rightskip}{0pt plus 5cm}void Object::warning (std::string {\em mymsg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, inherited\mbox{]}}}}
\label{classObject_a65cd4fda577711660821fd2cd5a3b4c9}


Definition at line 39 of file Object.h.

References Object::m\_\-log, Object::m\_\-name, MsgSvc::msgSvc(), and MsgSvc::WARNING.

Referenced by DCU::acquire(), A3PE::acquisition(), Plot::add(), Application::bookkeeping(), checkCmd(), Hierarchy::child(), Hierarchy::childTyped(), Processus::clean(), UsbSpiBus::clockDivider(), LSDelayChipV1::configRegBulkRead(), LSDelayChipV1::configRegBulkWrite(), Element::connection(), DCU::convert(), Application::create(), SpecsMezzanine::date(), SpecsGlue::date(), SpecsSlave::detect(), NI6008::device(), UsbFTInterfaceTest::execute(), Acquisition::execute(), A3PE\_\-BitFlip::execute(), export\_\-obj(), FEB\_\-v1::gbtAcknowledgeConfig(), FEB\_\-v1::gbtClockStrength(), FEB\_\-v1::gbtDLLReset(), LSDelayChipV1::getConfigReg(), SpecsGlue::i2cClkMode(), SpecsSlave::init(), DCU::init(), TestUSB::initialize(), TestSPI::initialize(), TestI2C::initialize(), EmulateFE::initialize(), StorageFifoAcquisition::initialize(), StorageFifo::initialize(), Acquisition::initialize(), A3PE\_\-BitFlip::initialize(), SpecsMezzanine::led(), SpecsGlue::led(), A3PE::loadTrigger(), Application::loop(), Application::makeDir(), Data::name(), Application::prepare(), UsbSpiBus::read(), UsbI2cBus::read(), ICPhaser::read(), Phaser::read(), DCU::readMode(), SpecsSlave::reset(), SpecsMaster::reset(), DCU::reset(), ICPhaser::reset(), SpecsSlave::resetInternal(), Server::Server(), FEB\_\-v1::setCalibCte(), StorageFifoAcquisition::setChannels(), Acquisition::setChannels(), UsbSpiBus::setClockDivider(), FEB\_\-v1::setClockFallingEdge(), Application::setConfig(), LSDelayChipV1::setConfigReg(), StorageFifoAcquisition::setDepth(), Acquisition::setDepth(), A3PE::setEnableADC(), FEB\_\-v1::setGain4(), FEB\_\-v1::setGbt80MHzClkEport(), FEB\_\-v1::setGbtClockStrength(), FEB\_\-v1::setGbtDataPath(), FEB\_\-v1::setGbtDLLEport(), FEB\_\-v1::setGbtEnableEport(), FEB\_\-v1::setGbtMode(), FEB\_\-v1::setGbtTermEport(), FEB\_\-v1::setGbtTrackMode(), DCU::setHIR(), SpecsGlue::setI2cClkMode(), SpecsMezzanine::setLed(), DCU::setLIR(), FEB\_\-v1::setOutputEport(), A3PE::setPipeline(), FEB\_\-v1::setPseudoADCEnable(), FEB\_\-v1::setPseudoPMEnable(), RAM::setSize(), SpecsMaster::setSpeed(), FEB\_\-v1::setStopInjLoop(), FEB\_\-v1::setTestDuration(), IOdata::setU16(), IOdata::setU32(), IOdata::setU8(), TestSuite::sigma(), SpecsInterface::specsReadI2c(), SpecsInterface::specsReadParallel(), SpecsInterface::specsReadRegister(), SpecsInterface::specsWriteI2c(), SpecsInterface::specsWriteParallel(), SpecsInterface::specsWriteRegister(), spiAddressScan(), LSDelayChipV1::spiBERTest(), spiFERTest(), spiRead(), spiWrite(), spiWriteSafe(), Server::start(), ICPhaser::status(), Application::svcPlot(), Application::svcRunning(), Data::title(), Server::updateConfig(), Server::updateState(), Data::vectorPtr(), UsbSpiBus::write(), UsbI2cBus::write(), ICPhaser::write(), Phaser::write(), FEB\_\-v1::writeFifoInjectFE(), and FEB\_\-v1::writeFifoLLTFE().


\begin{DoxyCode}
39 { m_log.msgSvc (MsgSvc::WARNING , mymsg, m_name ); }
\end{DoxyCode}
\hypertarget{classICECALv3_a9d7c33e6d113e7f721dc848d28ab44d8}{
\index{ICECALv3@{ICECALv3}!writeAsicParams@{writeAsicParams}}
\index{writeAsicParams@{writeAsicParams}!ICECALv3@{ICECALv3}}
\subsubsection[{writeAsicParams}]{\setlength{\rightskip}{0pt plus 5cm}bool ICECALv3::writeAsicParams (string {\em fileName}, \/  PyObject $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_a9d7c33e6d113e7f721dc848d28ab44d8}


Definition at line 156 of file ICECALv3.cpp.

References CALIBRATION\_\-FILE\_\-VER.

Referenced by dumpConfig().


\begin{DoxyCode}
157 {
158   time_t rawtime;
159   struct tm * timeinfo;
160     char dStr[64], tStr[64];
161     ofstream fd;
162     PyObject* l;        //Temporary list to accomodate 'asicParams' main list lis
      t objects.
163 
164     //'asicParams' output example:
165     //['R1403C0000', [19, 24, 0, 0, 1], [2, 3, 6, 0, 0, 0, 19, 48, 0], [19, 24, 0
      , 0, 1],
166     // [2, 3, 6, 0, 0, 0, 19, 48, 0], [19, 24, 0, 0, 1], [2, 3, 6, 0, 0, 0, 19, 4
      8, 0], 
167     // [19, 24, 0, 0, 1], [2, 3, 6, 0, 0, 0, 19, 48, 0], [0, 0, 0, 56, 0, 56, 0, 
      9, 56, 0, 56, 0]]
168 
169   time (&rawtime);
170   timeinfo = localtime (&rawtime);
171     strftime (dStr,64,"%Y/%m/%d",timeinfo);
172     strftime (tStr,64,"%R",timeinfo);   
173 
174     fd.open (fileName.c_str(), ios_base::out);
175     if(fd.is_open())
176     {
177         fd << "#########################################################" << endl
      ;
178         fd << "#############   ICECAL CALIBRATION FILE   ###############" << endl
      ;
179         fd << "#########################################################" << endl
      ;
180         fd << "" << endl;
181         fd << "#File Version     : v" << CALIBRATION_FILE_VER << endl;
182         fd << "#Date (YYYY/MM/DD): " << string(dStr) << endl;
183         fd << "#Time (HH:MM)     : " << string(tStr) << endl;
184         fd << "#ICECAL Chip ID   : " << PyString_AsString(PyList_GetItem(asicPara
      ms,0)) << endl;
185         fd << "" << endl << endl;
186     
187         fd << "#########################################################" << endl
      ;
188         fd << "# ICECAL Main Register Parameters:" << endl;
189         fd << "#########################################################" << endl
      ;
190         fd << "" << endl;
191 
192         l = PyList_GetItem(asicParams,9);       //list item 9. ICECAL Main config
       reg.
193         fd <<   "VCONTROL_OE = " << PyInt_AsLong(PyList_GetItem(l,0)) << endl;
194         fd <<   "BXID_SYN_OE = " << PyInt_AsLong(PyList_GetItem(l,1)) << endl;
195         fd <<   "CLK_REFRESH = " << PyInt_AsLong(PyList_GetItem(l,2)) << endl;
196         fd <<   "IBIAS_OB    = " << PyInt_AsLong(PyList_GetItem(l,3)) << endl;
197         fd <<   "IBIAS_CE_TH = " << PyInt_AsLong(PyList_GetItem(l,4)) << endl;
198         fd <<   "IBIAS_TH    = " << PyInt_AsLong(PyList_GetItem(l,5)) << endl;
199         fd <<   "IBIAS_INT   = " << PyInt_AsLong(PyList_GetItem(l,6)) << endl;
200         fd <<   "IBIAS_CE_IN = " << PyInt_AsLong(PyList_GetItem(l,7)) << endl;
201         fd <<   "IBIAS_CE_PZ = " << PyInt_AsLong(PyList_GetItem(l,8)) << endl;  
202         fd <<   "IBIAS_0T    = " << PyInt_AsLong(PyList_GetItem(l,9)) << endl;
203         fd <<   "IBIAS_PZ    = " << PyInt_AsLong(PyList_GetItem(l,10)) << endl;
204         fd <<   "IBIAS_V0T   = " << PyInt_AsLong(PyList_GetItem(l,11)) << endl;
205         fd << "" << endl << endl;
206 
207         for(int i=0;i<4;i++)
208         {
209             fd << "#########################################################" << 
      endl;
210             fd << "#Channel #" << i << " Parameters:" << endl;
211             fd << "#########################################################" << 
      endl;
212             fd << "" << endl;
213 
214             l = PyList_GetItem(asicParams,1+2*i);       //list items 1, 3, 5, 7. 
      Delay line config regs.
215             fd <<   "PHASE_ADC[" << i << "]   = " << PyInt_AsLong(PyList_GetItem(
      l,0)) << endl;
216             fd <<   "PHASE_TH[" << i << "]    = " << PyInt_AsLong(PyList_GetItem(
      l,1)) << endl;
217             fd <<   "PHASE_INT[" << i << "]   = " << PyInt_AsLong(PyList_GetItem(
      l,2)) << endl;
218             fd <<   "LOC_SEL[" << i << "]     = " << PyInt_AsLong(PyList_GetItem(
      l,3)) << endl;
219             fd <<   "LVDS_OEN[" << i << "]    = " << PyInt_AsLong(PyList_GetItem(
      l,4)) << endl;
220 
221             l = PyList_GetItem(asicParams,2+2*i);       //list items 2, 4, 6, 8. 
      ICECAL Analog config regs.
222             fd <<   "CINT_SUBCH0[" << i << "] = " << PyInt_AsLong(PyList_GetItem(
      l,0)) << endl;
223             fd <<   "CINT_SUBCH1[" << i << "] = " << PyInt_AsLong(PyList_GetItem(
      l,1)) << endl;
224             fd <<   "IOFF_SUBCH0[" << i << "] = " << PyInt_AsLong(PyList_GetItem(
      l,2)) << endl;
225             fd <<   "IOFF_SUBCH1[" << i << "] = " << PyInt_AsLong(PyList_GetItem(
      l,3)) << endl;
226             fd <<   "ZERO[" << i << "]        = " << PyInt_AsLong(PyList_GetItem(
      l,4)) << endl;
227             fd <<   "POLE[" << i << "]        = " << PyInt_AsLong(PyList_GetItem(
      l,5)) << endl;
228             fd <<   "ZIN[" << i << "]         = " << PyInt_AsLong(PyList_GetItem(
      l,6)) << endl;  
229             fd << "" << endl;
230         }
231 
232         fd.close();
233         return true;
234     }
235     else return false;
236 }
\end{DoxyCode}


\subsection{Member Data Documentation}
\hypertarget{classICECALv3_a6e8b6c03f5b0f1d8281bf8a0fa46064f}{
\index{ICECALv3@{ICECALv3}!confReg@{confReg}}
\index{confReg@{confReg}!ICECALv3@{ICECALv3}}
\subsubsection[{confReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Register}$\ast$ {\bf ICECALv3::confReg}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_a6e8b6c03f5b0f1d8281bf8a0fa46064f}


Definition at line 129 of file ICECALv3.h.

Referenced by ICECALv3(), setAddress(), spiRead(), and spiWrite().\hypertarget{classICECALv3_ad8989925ee5b3ff322d863ce6aaff0bd}{
\index{ICECALv3@{ICECALv3}!err@{err}}
\index{err@{err}!ICECALv3@{ICECALv3}}
\subsubsection[{err}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf ICECALv3::err}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_ad8989925ee5b3ff322d863ce6aaff0bd}


Definition at line 139 of file ICECALv3.h.

Referenced by getAnalogCh(), getDelayLineCh(), getMainReg(), setAnalogCh(), setDelayLineCh(), setMainReg(), spiRead(), and spiWrite().\hypertarget{classAttrib_a3414521d7a82476e874b25a5407b5e63}{
\index{ICECALv3@{ICECALv3}!m\_\-attribString@{m\_\-attribString}}
\index{m\_\-attribString@{m\_\-attribString}!ICECALv3@{ICECALv3}}
\subsubsection[{m\_\-attribString}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf Attrib::m\_\-attribString}\mbox{[}10\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected, inherited\mbox{]}}}}
\label{classAttrib_a3414521d7a82476e874b25a5407b5e63}


Definition at line 105 of file Attrib.h.

Referenced by Attrib::Attrib(), and Attrib::attributs().\hypertarget{classElement_abe3de7a5dbbc9a6dd2d7e012e5fdb266}{
\index{ICECALv3@{ICECALv3}!m\_\-connection@{m\_\-connection}}
\index{m\_\-connection@{m\_\-connection}!ICECALv3@{ICECALv3}}
\subsubsection[{m\_\-connection}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Hierarchy}$\ast$ {\bf Element::m\_\-connection}\hspace{0.3cm}{\ttfamily  \mbox{[}protected, inherited\mbox{]}}}}
\label{classElement_abe3de7a5dbbc9a6dd2d7e012e5fdb266}


Definition at line 70 of file Element.h.

Referenced by UsbSpiBus::clockDivider(), Element::connection(), Element::Element(), UsbSpiBus::init(), UsbI2cBus::init(), IOobject::init(), UsbMLSpiBus::init(), UsbMLI2cBus::init(), UsbSpiBus::read(), UsbI2cBus::read(), UsbSpiBus::setClockDivider(), Element::setConnection(), UsbSpiBus::write(), and UsbI2cBus::write().\hypertarget{classICECALv3_ae877ce34b3a4d6c368cc6409ac9614fa}{
\index{ICECALv3@{ICECALv3}!nRetries@{nRetries}}
\index{nRetries@{nRetries}!ICECALv3@{ICECALv3}}
\subsubsection[{nRetries}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf ICECALv3::nRetries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classICECALv3_ae877ce34b3a4d6c368cc6409ac9614fa}


Definition at line 137 of file ICECALv3.h.

Referenced by setNRetries(), and spiWriteSafe().

The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/home/eleclhcb/LHCb/lbcat-\/cmake/CatBcn/inc/\hyperlink{ICECALv3_8h}{ICECALv3.h}\item 
/home/eleclhcb/LHCb/lbcat-\/cmake/CatBcn/src/\hyperlink{ICECALv3_8cpp}{ICECALv3.cpp}\end{DoxyCompactItemize}
