\hypertarget{CatCaloUpgrade_2src_2Python_8cpp}{
\section{/home/eleclhcb/LHCb/lbcat-\/cmake/CatCaloUpgrade/src/Python.cpp File Reference}
\label{CatCaloUpgrade_2src_2Python_8cpp}\index{/home/eleclhcb/LHCb/lbcat-\/cmake/CatCaloUpgrade/src/Python.cpp@{/home/eleclhcb/LHCb/lbcat-\/cmake/CatCaloUpgrade/src/Python.cpp}}
}
{\ttfamily \#include $<$vector$>$}\par
{\ttfamily \#include $<$list$>$}\par
{\ttfamily \#include \char`\"{}Processus.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}Element.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}FEB\_\-v1.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}CU\_\-v1.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}SeqPGA.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}FePGA.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}UsbFTMLInterface.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}UsbMLSpiBus.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}UsbMLI2cBus.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}ICPhaser.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}TestUSB.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}TestSPI.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}TestI2C.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}Acquisition.h\char`\"{}}\par
{\ttfamily \#include $<$boost/python.hpp$>$}\par
{\ttfamily \#include $<$boost/python/suite/indexing/vector\_\-indexing\_\-suite.hpp$>$}\par
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{CatCaloUpgrade_2src_2Python_8cpp_a5142f09cbd1228dce82c092764a94364}{BOOST\_\-PYTHON\_\-MODULE} (libCatCaloUpgrade)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{CatCaloUpgrade_2src_2Python_8cpp_a5142f09cbd1228dce82c092764a94364}{
\index{CatCaloUpgrade/src/Python.cpp@{CatCaloUpgrade/src/Python.cpp}!BOOST\_\-PYTHON\_\-MODULE@{BOOST\_\-PYTHON\_\-MODULE}}
\index{BOOST\_\-PYTHON\_\-MODULE@{BOOST\_\-PYTHON\_\-MODULE}!CatCaloUpgrade/src/Python.cpp@{CatCaloUpgrade/src/Python.cpp}}
\subsubsection[{BOOST\_\-PYTHON\_\-MODULE}]{\setlength{\rightskip}{0pt plus 5cm}BOOST\_\-PYTHON\_\-MODULE (libCatCaloUpgrade)}}
\label{CatCaloUpgrade_2src_2Python_8cpp_a5142f09cbd1228dce82c092764a94364}


Definition at line 26 of file Python.cpp.

References SeqPGA::addI2cReg(), ICPhaser::address(), FEB\_\-v1::calibCte(), FEB\_\-v1::clock80MHzFallingEdge(), FEB\_\-v1::clockFallingEdge(), FEB\_\-v1::clockPhaseEport(), UsbFTMLInterface::close(), FEB\_\-v1::data(), UsbFTMLInterface::deviceDesc(), FEB\_\-v1::disableSubtract(), FEB\_\-v1::enableBXIDReset(), SeqPGA::extTrig(), FEB\_\-v1::extTrig(), CU\_\-v1::fePga(), FEB\_\-v1::gain4(), FEB\_\-v1::gbt80MHzClkEport(), FEB\_\-v1::gbtAcknowledgeConfig(), FEB\_\-v1::gbtClockStrength(), FEB\_\-v1::gbtDataPath(), FEB\_\-v1::gbtDLLEport(), FEB\_\-v1::gbtDLLReset(), FEB\_\-v1::gbtEnableEport(), FEB\_\-v1::gbtMode(), FEB\_\-v1::gbtStatus(), FEB\_\-v1::gbtTermEport(), FEB\_\-v1::gbtTrackMode(), FEB\_\-v1::globalPseudoPMEnable(), FePGA::i2c(), SeqPGA::i2c(), SeqPGA::i2cAdd(), SeqPGA::i2cBuffer(), SeqPGA::i2cData(), SeqPGA::i2cGBTSCA(), SeqPGA::i2cRead(), SeqPGA::i2cSubAdd(), SeqPGA::i2cWrite(), UsbFTMLInterface::init(), FEB\_\-v1::injectModeFE(), FEB\_\-v1::latency(), FEB\_\-v1::latencyEport(), FEB\_\-v1::latencyLLT(), UsbFTMLInterface::latencyTimer(), SeqPGA::ledEnable(), FEB\_\-v1::maskLLT(), SeqPGA::masterI2cReg(), FEB\_\-v1::oldSubtract(), FEB\_\-v1::probeEnable(), FEB\_\-v1::pseudoADCEnable(), FEB\_\-v1::pseudoPMEnable(), UsbFTMLInterface::purgeBuffers(), FEB\_\-v1::ramInj(), FEB\_\-v1::ramSpy(), ICPhaser::read(), UsbFTMLInterface::read(), CU\_\-v1::readFifo(), FEB\_\-v1::readFifoInjectFE(), FEB\_\-v1::readFifoLLT(), FEB\_\-v1::readFifoLLTFE(), FEB\_\-v1::readFifoSpyFE(), SeqPGA::reg(), ICPhaser::regConfig(), ICPhaser::regStatus(), ICPhaser::reset(), FEB\_\-v1::resetFE(), FEB\_\-v1::resetFifoInjectFE(), FEB\_\-v1::resetFifoSpyFE(), UsbFTMLInterface::resetMode(), FEB\_\-v1::resetSpi(), UsbFTMLInterface::rxBuffer(), UsbFTMLInterface::rxTimeOut(), FEB\_\-v1::seqPga(), UsbFTMLInterface::serialNum(), TestI2C::setAddress(), TestSPI::setAddress(), ICPhaser::setAddress(), UsbFTMLInterface::setBuffer(), FEB\_\-v1::setCalibCte(), FEB\_\-v1::setClock80MHzFallingEdge(), FEB\_\-v1::setClockFallingEdge(), Acquisition::setDepth(), UsbFTMLInterface::setDeviceDesc(), FEB\_\-v1::setDisableSubtract(), FEB\_\-v1::setEnableBXIDReset(), SeqPGA::setExtTrig(), FEB\_\-v1::setExtTrig(), FEB\_\-v1::setGain4(), FEB\_\-v1::setGbt80MHzClkEport(), FEB\_\-v1::setGbtClockStrength(), FEB\_\-v1::setGbtDataPath(), FEB\_\-v1::setGbtDLLEport(), FEB\_\-v1::setGbtEnableEport(), FEB\_\-v1::setGbtMode(), FEB\_\-v1::setGbtTermEport(), FEB\_\-v1::setGbtTrackMode(), FEB\_\-v1::setGlobalPseudoPMEnable(), SeqPGA::setI2cAdd(), SeqPGA::setI2cBuffer(), SeqPGA::setI2cGBTSCA(), SeqPGA::setI2cSubAdd(), FEB\_\-v1::setInjectModeFE(), FEB\_\-v1::setLatency(), FEB\_\-v1::setLatencyLLT(), FEB\_\-v1::setLatencyLLTCorner(), FEB\_\-v1::setLatencyLLTSideNb(), FEB\_\-v1::setLatencyLLTUpNb(), UsbFTMLInterface::setLatencyTimer(), SeqPGA::setLedEnable(), FEB\_\-v1::setMaskLLT(), FEB\_\-v1::setMaskLLTCorner(), FEB\_\-v1::setMaskLLTSideNb(), FEB\_\-v1::setMaskLLTUpNb(), FEB\_\-v1::setOldSubtract(), FEB\_\-v1::setOutputEport(), ICPhaser::setPhase(), FEB\_\-v1::setProbeEnable(), FEB\_\-v1::setPseudoADCEnable(), FEB\_\-v1::setPseudoPMEnable(), UsbFTMLInterface::setSerialNum(), FEB\_\-v1::setSpareForTrigEnable(), FePGA::setSpiAdd(), SeqPGA::setSpiAdd(), SeqPGA::setSpiEnable(), FePGA::setSpiGBTSCA(), SeqPGA::setSpiGBTSCA(), SeqPGA::setSpiSubAdd(), FEB\_\-v1::setSpyModeFE(), FEB\_\-v1::setSpyModeSeq(), FEB\_\-v1::setStopInjLoop(), TestI2C::setSubAddress(), TestSPI::setSubAddress(), UsbFTMLInterface::setSynchronousMode(), FEB\_\-v1::setTestDuration(), FEB\_\-v1::setThreshold(), UsbFTMLInterface::setTimeOut(), Acquisition::setTrigger(), FePGA::setupReg(), SeqPGA::setupReg(), UsbFTMLInterface::setWordSize(), FEB\_\-v1::spareForTrigEnable(), FePGA::spi(), SeqPGA::spi(), SeqPGA::spiAdd(), SeqPGA::spiEnable(), SeqPGA::spiGBTSCA(), FePGA::spiRead(), SeqPGA::spiRead(), SeqPGA::spiSubAdd(), FePGA::spiWrite(), SeqPGA::spiWrite(), FEB\_\-v1::spyModeFE(), FEB\_\-v1::spyModeSeq(), ICPhaser::status(), FEB\_\-v1::statusRegister(), FEB\_\-v1::stopInjLoop(), FEB\_\-v1::testDuration(), SeqPGA::testSequence(), FEB\_\-v1::testSequence(), FEB\_\-v1::threshold(), UsbFTMLInterface::txBuffer(), UsbFTMLInterface::txTimeOut(), FePGA::usb(), SeqPGA::usb(), UsbFTMLInterface::wordSize(), ICPhaser::write(), UsbFTMLInterface::write(), FEB\_\-v1::writeDataFifoInjectFE(), FEB\_\-v1::writeFifoInjectFE(), FEB\_\-v1::writeFifoLLT(), FEB\_\-v1::writeFifoLLTFE(), FEB\_\-v1::writeFifoSpyFE(), UsbFTMLInterface::WS\_\-Byte, UsbFTMLInterface::WS\_\-DWord, and UsbFTMLInterface::WS\_\-Word.


\begin{DoxyCode}
27 {
28 
29 
30   StatusCode (FEB_v1::*setOutputEport1)(int, int, int, int) = (&
      FEB_v1::setOutputEport);
31   StatusCode (FEB_v1::*setOutputEport2)(int, int, int) = (&
      FEB_v1::setOutputEport);
32 
33   int (FEB_v1::*latencyEport1)(int, int) = (&FEB_v1::latencyEport);
34   int (FEB_v1::*latencyEport2)(int) = (&FEB_v1::latencyEport);
35 
36   int (FEB_v1::*clockPhaseEport1)(int, int) = (&FEB_v1::clockPhaseEport);
37   int (FEB_v1::*clockPhaseEport2)(int) = (&FEB_v1::clockPhaseEport);
38 
39   class_<FEB_v1, bases <Element> >("FEB_v1")
40     .def("seqPga"           ,&FEB_v1::seqPga,return_value_policy<reference_existi
      ng_object>())
41     .def("ramInj"           ,&FEB_v1::ramInj,return_value_policy<reference_existi
      ng_object>())
42     .def("ramSpy"           ,&FEB_v1::ramSpy,return_value_policy<reference_existi
      ng_object>())
43    
44     .def("testSequence"     ,&FEB_v1::testSequence)
45     .def("setExtTrig"       ,&FEB_v1::setExtTrig)
46     .def("extTrig"          ,&FEB_v1::extTrig)
47 
48     .def("readFifoSpyFE"    ,&FEB_v1::readFifoSpyFE)
49     .def("readFifoLLTFE"    ,&FEB_v1::readFifoLLTFE)
50     .def("readFifoLLT"      ,&FEB_v1::readFifoLLT)
51     .def("readFifoInjectFE" ,&FEB_v1::readFifoInjectFE)
52     .def("writeFifoSpyFE"   ,&FEB_v1::writeFifoSpyFE)
53     .def("writeFifoLLTFE"   ,&FEB_v1::writeFifoLLTFE)
54     .def("writeFifoLLT"     ,&FEB_v1::writeFifoLLT)
55     .def("writeFifoInjectFE",&FEB_v1::writeFifoInjectFE)
56     .def("writeDataFifoInjectFE",&FEB_v1::writeDataFifoInjectFE)
57 
58     .def("latencyLLT"       ,&FEB_v1::latencyLLT)
59     .def("setLatencyLLT"       ,&FEB_v1::setLatencyLLT)
60     .def("setLatencyLLTCorner" ,&FEB_v1::setLatencyLLTCorner)
61     .def("setLatencyLLTUpNb"   ,&FEB_v1::setLatencyLLTUpNb)
62     .def("setLatencyLLTSideNb" ,&FEB_v1::setLatencyLLTSideNb)
63 
64     .def("maskLLT"      ,&FEB_v1::maskLLT)
65     .def("setMaskLLT"       ,&FEB_v1::setMaskLLT)
66     .def("setMaskLLTCorner" ,&FEB_v1::setMaskLLTCorner)
67     .def("setMaskLLTUpNb"   ,&FEB_v1::setMaskLLTUpNb)
68     .def("setMaskLLTSideNb" ,&FEB_v1::setMaskLLTSideNb)
69 
70 
71     .def("resetFifoSpyFE"    ,&FEB_v1::resetFifoSpyFE)
72     .def("resetFifoInjectFE" ,&FEB_v1::resetFifoInjectFE)
73     .def("resetSpi"          ,&FEB_v1::resetSpi)
74     .def("resetFE"           ,&FEB_v1::resetFE)
75     
76     .def("setSpareForTrigEnable"   ,&FEB_v1::setSpareForTrigEnable)
77     .def("spareForTrigEnable"      ,&FEB_v1::spareForTrigEnable)
78     .def("setProbeEnable"   ,&FEB_v1::setProbeEnable)
79     .def("probeEnable"      ,&FEB_v1::probeEnable)
80     .def("setTestDuration"  ,&FEB_v1::setTestDuration)
81     .def("testDuration"     ,&FEB_v1::testDuration)
82     .def("setStopInjLoop" ,&FEB_v1::setStopInjLoop)
83     .def("stopInjLoop"    ,&FEB_v1::stopInjLoop)
84     .def("setSpyModeSeq"    ,&FEB_v1::setSpyModeSeq)
85     .def("spyModeSeq"       ,&FEB_v1::spyModeSeq)
86     .def("setSpyModeFE"     ,&FEB_v1::setSpyModeFE)
87     .def("spyModeFE"        ,&FEB_v1::spyModeFE)
88     .def("setSpyModeFE"     ,&FEB_v1::setSpyModeFE)
89     .def("spyModeFE"        ,&FEB_v1::spyModeFE)
90     .def("setDisableSubtract",&FEB_v1::setDisableSubtract)
91     .def("disableSubtract"   ,&FEB_v1::disableSubtract)
92     .def("setOldSubtract"   ,&FEB_v1::setOldSubtract)
93     .def("oldSubtract"      ,&FEB_v1::oldSubtract)
94     .def("setThreshold"     ,&FEB_v1::setThreshold)
95     .def("threshold"        ,&FEB_v1::threshold)
96     .def("setLatency"       ,&FEB_v1::setLatency)
97     .def("latency"          ,&FEB_v1::latency)
98     .def("setSpyModeFE"     ,&FEB_v1::setSpyModeFE)
99     .def("spyModeFE"        ,&FEB_v1::spyModeFE)
100     .def("setSpyModeFE"     ,&FEB_v1::setSpyModeFE)
101     .def("spyModeFE"        ,&FEB_v1::spyModeFE)
102     .def("setInjectModeFE"  ,&FEB_v1::setInjectModeFE)
103     .def("injectModeFE"     ,&FEB_v1::injectModeFE)
104     .def("statusRegister"   ,&FEB_v1::statusRegister)
105     .def("setEnableBXIDReset" ,&FEB_v1::setEnableBXIDReset)
106     .def("enableBXIDReset"    ,&FEB_v1::enableBXIDReset)
107 
108     .def("setGain4"                  ,&FEB_v1::setGain4)
109     .def("setPseudoADCEnable"        ,&FEB_v1::setPseudoADCEnable)
110     .def("setPseudoPMEnable"         ,&FEB_v1::setPseudoPMEnable)
111     .def("setGlobalPseudoPMEnable"   ,&FEB_v1::setGlobalPseudoPMEnable)
112     .def("setClockFallingEdge" ,&FEB_v1::setClockFallingEdge)
113     .def("setCalibCte"         ,&FEB_v1::setCalibCte)
114     .def("gain4"               ,&FEB_v1::gain4)
115     .def("pseudoADCEnable"     ,&FEB_v1::pseudoADCEnable)
116     .def("pseudoPMEnable"      ,&FEB_v1::pseudoPMEnable)
117     .def("globalPseudoPMEnable",&FEB_v1::globalPseudoPMEnable)
118     .def("setClockFallingEdge" ,&FEB_v1::setClockFallingEdge)
119     .def("clockFallingEdge"    ,&FEB_v1::clockFallingEdge)
120     .def("setClock80MHzFallingEdge" ,&FEB_v1::setClock80MHzFallingEdge)
121     .def("clock80MHzFallingEdge"    ,&FEB_v1::clock80MHzFallingEdge)
122     .def("setCalibCte"         ,&FEB_v1::setCalibCte)
123     .def("calibCte"            ,&FEB_v1::calibCte)
124     
125     .def("setGbtMode"          ,&FEB_v1::setGbtMode)
126     .def("gbtMode"             ,&FEB_v1::gbtMode)
127     .def("setGbtDataPath"      ,&FEB_v1::setGbtDataPath)
128     .def("gbtDataPath"         ,&FEB_v1::gbtDataPath)
129     .def("setGbtTrackMode"     ,&FEB_v1::setGbtTrackMode)
130     .def("gbtTrackMode"        ,&FEB_v1::gbtTrackMode)
131     .def("setGbtTermEport"     ,&FEB_v1::setGbtTermEport)
132     .def("gbtTermEport"        ,&FEB_v1::gbtTermEport)
133     .def("setGbt80MHzClkEport" ,&FEB_v1::setGbt80MHzClkEport)
134     .def("gbt80MHzClkEport"    ,&FEB_v1::gbt80MHzClkEport)
135     .def("setGbtDLLEport"      ,&FEB_v1::setGbtDLLEport)
136     .def("gbtDLLEport"         ,&FEB_v1::gbtDLLEport)
137     .def("setGbtEnableEport"   ,&FEB_v1::setGbtEnableEport)
138     .def("gbtEnableEport"      ,&FEB_v1::gbtEnableEport)
139     .def("setGbtClockStrength"   ,&FEB_v1::setGbtClockStrength)
140     .def("gbtClockStrength"      ,&FEB_v1::gbtClockStrength)
141     .def("gbtStatus"           ,&FEB_v1::gbtStatus)
142     .def("gbtDLLReset"         ,&FEB_v1::gbtDLLReset)
143     .def("gbtAcknowledgeConfig",&FEB_v1::gbtAcknowledgeConfig)
144 
145     .def("setOutputEport"      ,setOutputEport1)
146     .def("latencyEport"        ,latencyEport1)
147     .def("clockPhaseEport"     ,clockPhaseEport1)
148 
149     .def("setOutputEport"      ,setOutputEport2)
150     .def("latencyEport"        ,latencyEport2)
151     .def("clockPhaseEport"     ,clockPhaseEport2)
152    
153     .def("data",&FEB_v1::data,return_value_policy<reference_existing_object>())
154     ;
155   
156   StatusCode (SeqPGA::*spiwrite_1)(unsigned int, unsigned int) = (&
      SeqPGA::spiWrite);
157   StatusCode (SeqPGA::*spiwrite_2)(unsigned int, unsigned int, PyObject*) = (&
      SeqPGA::spiWrite);
158 
159   unsigned int (SeqPGA::*spiread_1)(unsigned int) = (&SeqPGA::spiRead);
160   PyObject* (SeqPGA::*spiread_2)(unsigned int, unsigned int) = (&SeqPGA::spiRead)
      ;
161 
162   StatusCode (SeqPGA::*i2cwrite_1)() = (&SeqPGA::i2cWrite);
163   StatusCode (SeqPGA::*i2cwrite_2)(unsigned long int, unsigned long int) = (&
      SeqPGA::i2cWrite);
164   StatusCode (SeqPGA::*i2cread_1)() = (&SeqPGA::i2cRead);
165   unsigned long int (SeqPGA::*i2cread_2)(unsigned long int) = (&SeqPGA::i2cRead);
      
166 
167   class_<SeqPGA, bases <Element> >("SeqPGA")
168     .def("usb",&SeqPGA::usb,return_value_policy<reference_existing_object>())
169     .def("spi",&SeqPGA::spi,return_value_policy<reference_existing_object>())
170     .def("i2c",&SeqPGA::i2c,return_value_policy<reference_existing_object>())
171     .def("reg",&SeqPGA::reg,return_value_policy<reference_existing_object>())
172 
173     .def("setupReg",&SeqPGA::setupReg,return_value_policy<reference_existing_obje
      ct>())
174 
175     .def("testSequence"    ,&SeqPGA::testSequence)
176     .def("setExtTrig"      ,&SeqPGA::setExtTrig)
177     .def("extTrig"         ,&SeqPGA::extTrig)
178     
179 
180     .def("setSpiGBTSCA"  ,&SeqPGA::setSpiGBTSCA)
181     .def("spiGBTSCA"     ,&SeqPGA::spiGBTSCA)
182     .def("setSpiEnable"  ,&SeqPGA::setSpiEnable)
183     .def("spiEnable"     ,&SeqPGA::spiEnable)
184     .def("setLedEnable"  ,&SeqPGA::setLedEnable)
185     .def("ledEnable"     ,&SeqPGA::ledEnable)
186     //    .def("setSpiDataTx"  ,&SeqPGA::setSpiDataTx)
187     //    .def("spiDataTx"     ,&SeqPGA::spiDataTx)
188     //    .def("setSpiDataRx"  ,&SeqPGA::setSpiDataRx)
189     //    .def("spiDataRx"     ,&SeqPGA::spiDataRx) 
190     .def("setSpiAdd"     ,&SeqPGA::setSpiAdd)
191     .def("spiAdd"        ,&SeqPGA::spiAdd) 
192     .def("setSpiSubAdd"  ,&SeqPGA::setSpiSubAdd)
193     .def("spiSubAdd"      ,&SeqPGA::spiSubAdd)
194     .def("spiWrite"          ,spiwrite_1)
195     .def("spiWrite"          ,spiwrite_2)
196     .def("spiRead"           ,spiread_1)
197     .def("spiRead"           ,spiread_2)
198 
199     .def("addI2cReg"       ,&SeqPGA::addI2cReg,return_value_policy<reference_exis
      ting_object>())
200     .def("masterI2cReg",&SeqPGA::masterI2cReg,return_value_policy<reference_exist
      ing_object>())
201 
202     .def("setI2cGBTSCA"    ,&SeqPGA::setI2cGBTSCA)
203     .def("i2cGBTSCA"       ,&SeqPGA::i2cGBTSCA)
204     .def("setI2cBuffer"    ,&SeqPGA::setI2cBuffer)
205     .def("buffer"          ,&SeqPGA::i2cBuffer)
206     .def("i2cData"            ,&SeqPGA::i2cData)
207     .def("setI2cAdd"       ,&SeqPGA::setI2cAdd)
208     .def("i2cAdd"             ,&SeqPGA::i2cAdd) 
209     .def("setI2cSubAdd"    ,&SeqPGA::setI2cSubAdd)
210     .def("i2cSubAdd"          ,&SeqPGA::i2cSubAdd)
211     .def("i2cWrite"        ,i2cwrite_1)
212     .def("i2cWrite"        ,i2cwrite_2)
213     .def("i2cRead"         ,i2cread_1)
214     .def("i2cRead"         ,i2cread_2)
215    ;
216   
217  class_<CU_v1, bases <Element> >("CU_v1")
218    .def("fePga"           ,&CU_v1::fePga,return_value_policy<reference_existing_o
      bject>())
219    .def("readFifo"    ,&CU_v1::readFifo)
220 
221  ;
222 
223  StatusCode (FePGA::*spiwrite_3)(unsigned int, unsigned int) = (&FePGA::spiWrite)
      ;
224  StatusCode (FePGA::*spiwrite_4)(unsigned int, unsigned int, PyObject*) = (&
      FePGA::spiWrite);
225 
226  unsigned int (FePGA::*spiread_3)(unsigned int) = (&FePGA::spiRead);
227  PyObject* (FePGA::*spiread_4)(unsigned int, unsigned int) = (&FePGA::spiRead);
228 
229 
230  class_<FePGA, bases <Element> >("FePGA")
231    .def("usb",&FePGA::usb,return_value_policy<reference_existing_object>())
232    .def("spi",&FePGA::spi,return_value_policy<reference_existing_object>())
233    .def("i2c",&FePGA::i2c,return_value_policy<reference_existing_object>())
234    //.def("reg",&FePGA::reg,return_value_policy<reference_existing_object>())
235    .def("setupReg",&FePGA::setupReg,return_value_policy<reference_existing_object
      >())
236    // .def("testSequence"    ,&FePGA::testSequence)
237    // .def("setExtTrig"      ,&FePGA::setExtTrig)
238    // .def("extTrig"         ,&FePGA::extTrig)
239    .def("setSpiGBTSCA"  ,&FePGA::setSpiGBTSCA)
240    // .def("spiGBTSCA"     ,&FePGA::spiGBTSCA)
241    .def("setSpiAdd"     ,&FePGA::setSpiAdd)
242    // .def("spiAdd"        ,&FePGA::spiAdd) 
243    // .def("setSpiSubAdd"  ,&FePGA::setSpiSubAdd)
244    // .def("spiSubAdd"      ,&FePGA::spiSubAdd)
245    .def("spiWrite"          ,spiwrite_3)
246    .def("spiWrite"          ,spiwrite_4)
247 
248    .def("spiRead"           ,spiread_3) //This is needed by readfifo
249    .def("spiRead"           ,spiread_4)
250    // .def("addI2cReg"       ,&FePGA::addI2cReg,return_value_policy<reference_exi
      sting_object>())
251    //.def("masterI2cReg",&FePGA::masterI2cReg,return_value_policy<reference_exist
      ing_object>())
252    // .def("setI2cGBTSCA"    ,&FePGA::setI2cGBTSCA)
253    // .def("i2cGBTSCA"       ,&FePGA::i2cGBTSCA)
254    // .def("setI2cBuffer"    ,&FePGA::setI2cBuffer)
255    // .def("buffer"          ,&FePGA::i2cBuffer)
256    // .def("i2cData"            ,&FePGA::i2cData)
257    // .def("setI2cAdd"       ,&FePGA::setI2cAdd)
258    // .def("i2cAdd"             ,&FePGA::i2cAdd) 
259    // .def("setI2cSubAdd"    ,&FePGA::setI2cSubAdd)
260    // .def("i2cSubAdd"          ,&FePGA::i2cSubAdd)
261    // .def("i2cWrite"        ,i2cwrite_1)
262    //  .def("i2cWrite"        ,i2cwrite_2)
263    // .def("i2cRead"         ,i2cread_1)
264    //  .def("i2cRead"         ,i2cread_2)
265    ;
266     
267 
268   enum_<UsbFTMLInterface::WordSize>("WordSize")
269     .value("U8", UsbFTMLInterface::WS_Byte)
270     .value("U16", UsbFTMLInterface::WS_Word)
271     .value("U32", UsbFTMLInterface::WS_DWord)
272    ;
273 
274   StatusCode (UsbFTMLInterface::*write_1)(unsigned long int, boost::python::list)
       = (&UsbFTMLInterface::write);
275   StatusCode (UsbFTMLInterface::*write_2)(IOdata*) = (&UsbFTMLInterface::write);
276   StatusCode (UsbFTMLInterface::*read_1)(unsigned long int,unsigned long int, boo
      st::python::list&) = (&UsbFTMLInterface::read);
277   StatusCode (UsbFTMLInterface::*read_2)(IOdata*) = (&UsbFTMLInterface::read);
278 
279   class_<UsbFTMLInterface, bases <Element> > ("UsbFTMLInterface")
280     .def("init"           ,&UsbFTMLInterface::init)
281     .def("setSerialNum"   ,&UsbFTMLInterface::setSerialNum)
282     .def("setDeviceDesc"  ,&UsbFTMLInterface::setDeviceDesc)
283     .def("serialNum"      ,&UsbFTMLInterface::serialNum)
284     .def("deviceDesc"     ,&UsbFTMLInterface::deviceDesc)
285     .def("setWordSize"    ,&UsbFTMLInterface::setWordSize)
286     .def("wordSize"       ,&UsbFTMLInterface::wordSize)
287     .def("close"          ,&UsbFTMLInterface::close)
288     .def("setLatencyTimer",&UsbFTMLInterface::setLatencyTimer)
289     .def("latencyTimer"   ,&UsbFTMLInterface::latencyTimer)
290     .def("setTimeOut"     ,&UsbFTMLInterface::setTimeOut)
291     .def("txTimeOut"      ,&UsbFTMLInterface::txTimeOut)
292     .def("rxTimeOut"      ,&UsbFTMLInterface::rxTimeOut)
293     .def("setBuffer"      ,&UsbFTMLInterface::setBuffer)
294     .def("txBuffer"       ,&UsbFTMLInterface::txBuffer)
295     .def("rxBuffer"       ,&UsbFTMLInterface::rxBuffer)
296     .def("resetMode"         ,&UsbFTMLInterface::resetMode)
297     .def("purgeBuffers"      ,&UsbFTMLInterface::purgeBuffers)
298     .def("setSynchronousMode",&UsbFTMLInterface::setSynchronousMode)
299     .def("write"          ,write_1)
300     .def("write"          ,write_2)
301     .def("read"           ,read_1)
302     .def("read"           ,read_2)
303     ;
304  
305   class_<UsbMLSpiBus, bases <Element> >("UsbMLSpiBus")
306     ;
307   
308   class_<UsbMLI2cBus, bases <Element> >("UsbMLI2cBus")
309     ;
310   
311   void (ICPhaser::*setPhasex2)(unsigned char, unsigned char) = (&
      ICPhaser::setPhase);
312   void (ICPhaser::*setPhasex4)(unsigned char, unsigned char,
313                    unsigned char, unsigned char) = (&ICPhaser::setPhase);
314 
315   class_<ICPhaser, bases <Element> >("ICPhaser")
316     .def("setPhase",setPhasex2)
317     .def("setPhase",setPhasex4)
318     .def("setAddress",&ICPhaser::setAddress)
319     .def("address",&ICPhaser::address)
320     .def("status",&ICPhaser::status)
321     .def("reset",&ICPhaser::reset)
322     .def("read" ,&ICPhaser::read)
323     .def("write",&ICPhaser::write)
324     .def("regConfig"  ,&ICPhaser::regConfig,
325      return_value_policy<reference_existing_object>())
326     .def("regStatus"  ,&ICPhaser::regStatus,
327      return_value_policy<reference_existing_object>())
328     ;
329 
330   //    class_<TestUSB, bases<Processus> > ("TestUSB")
331   //    ;  
332 
333   class_<TestSPI, bases<Processus> > ("TestSPI")
334     .def("setAddress",     &TestSPI::setAddress)
335     .def("setSubAddress",  &TestSPI::setSubAddress) 
336     ;  
337 
338   class_<TestI2C, bases<Processus> > ("TestI2C")
339     .def("setAddress",     &TestI2C::setAddress)
340     .def("setSubAddress",  &TestI2C::setSubAddress) 
341     ;  
342 
343   class_<Acquisition, bases<Processus> > ("Acquisition")
344     .def("setDepth"  , &Acquisition::setDepth)
345     .def("setTrigger", &Acquisition::setTrigger) 
346     ;  
347 
348 }
\end{DoxyCode}
